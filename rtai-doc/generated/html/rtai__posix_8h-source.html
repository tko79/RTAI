<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_posix.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_posix.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This library is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment"> * License as published by the Free Software Foundation; either</span>
00007 <span class="comment"> * version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment"> * Lesser General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment"> * You should have received a copy of the GNU Lesser General Public</span>
00015 <span class="comment"> * License along with this library; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> */</span>
00019 
00020 <span class="preprocessor">#ifndef _RTAI_POSIX_H_</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_POSIX_H_</span>
00022 <span class="preprocessor"></span>
00023 <span class="preprocessor">#ifdef __KERNEL__</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include &lt;rtai_malloc.h&gt;</span>
00026 <span class="preprocessor">#include &lt;rtai_rwl.h&gt;</span>
00027 <span class="preprocessor">#include &lt;rtai_spl.h&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00029 
00030 <span class="preprocessor">#define MAX_PRIO       99</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define MIN_PRIO       1</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define STACK_SIZE     8192</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define RR_QUANTUM_NS  1000000</span>
00034 <span class="preprocessor"></span>
00035 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore sem_t;
00036 
00037 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore pthread_mutex_t;
00038 
00039 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pthread_mutexattr_t;
00040 
00041 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore pthread_cond_t;
00042 
00043 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pthread_condattr_t;
00044 
00045 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore pthread_barrier_t;
00046 
00047 <span class="keyword">typedef</span> <span class="keywordtype">int</span> pthread_barrierattr_t;
00048 
00049 <span class="keyword">typedef</span> RWL pthread_rwlock_t;
00050 
00051 <span class="keyword">typedef</span> <span class="keywordtype">int</span> pthread_rwlockattr_t;
00052 
00053 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_spl_t pthread_spinlock_t;
00054 
00055 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct *pthread_t;
00056 
00057 <span class="keyword">typedef</span> <span class="keyword">struct </span>pthread_attr {
00058 
00059     <span class="keywordtype">int</span> stacksize;
00060     <span class="keywordtype">int</span> policy;
00061     <span class="keywordtype">int</span> rr_quantum_ns;
00062     <span class="keywordtype">int</span> priority;
00063 
00064 } pthread_attr_t;
00065 
00066 <span class="keyword">typedef</span> <span class="keyword">struct </span>pthread_cookie {
00067 
00068     RT_TASK task;
00069     SEM sem;
00070     void (*task_fun)(<span class="keywordtype">int</span>);
00071     <span class="keywordtype">int</span> arg;
00072 
00073 } pthread_cookie_t;
00074 
00075 <span class="preprocessor">#ifdef __cplusplus</span>
00076 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00077 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00078 
00079 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_init_rt(sem_t *sem, <span class="keywordtype">int</span> pshared, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
00080 {
00081         <span class="keywordflow">if</span> (value &lt; SEM_TIMOUT) {
00082                 <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(sem, value, pshared | PRIO_Q);
00083                 <span class="keywordflow">return</span> 0;
00084         }
00085         <span class="keywordflow">return</span> -EINVAL;
00086 }
00087 
00088 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_destroy_rt(sem_t *sem)
00089 {
00090         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt;= 0) {
00091                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00092                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(sem);
00093         }
00094         <span class="keywordflow">return</span> -EBUSY;
00095 }
00096 
00097 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_wait_rt(sem_t *sem)
00098 {
00099         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(sem) &lt; SEM_TIMOUT ? 0 : -1;
00100 }
00101 
00102 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_trywait_rt(sem_t *sem)
00103 {
00104         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt; 0 ? 0 : -EAGAIN;
00105 }
00106 
00107 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_timedwait_rt(sem_t *sem, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)
00108 {
00109         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00110 }
00111 
00112 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_post_rt(sem_t *sem)
00113 {
00114         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem) &lt; SEM_TIMOUT ? 0 : -ERANGE;
00115 }
00116 
00117 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_getvalue_rt(sem_t *sem, <span class="keywordtype">int</span> *sval)
00118 {
00119         <span class="keywordflow">if</span> ((*sval = <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem)) &gt; 0) {
00120                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00121         }
00122         <span class="keywordflow">return</span> 0;
00123 }
00124 
00125 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_init_rt(pthread_mutex_t *mutex, <span class="keyword">const</span> pthread_mutexattr_t *mutexattr)
00126 {
00127         <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(mutex, 1, RES_SEM);
00128         <span class="keywordflow">return</span> 0;
00129 }
00130 
00131 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_destroy_rt(pthread_mutex_t *mutex)
00132 {
00133         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0) {
00134                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(mutex);
00135                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(mutex);
00136         }
00137         <span class="keywordflow">return</span> -EBUSY;
00138 }
00139 
00140 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_lock_rt(pthread_mutex_t *mutex)
00141 {
00142         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(mutex) &lt; SEM_TIMOUT ? 0 : -EINVAL;
00143 }
00144 
00145 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_timedlock_rt(pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)
00146 {
00147         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(mutex, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00148 }
00149 
00150 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_trylock_rt(pthread_mutex_t *mutex)
00151 {
00152         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0 ? 0 : -EBUSY;
00153 }
00154 
00155 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_unlock_rt(pthread_mutex_t *mutex)
00156 {
00157         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(mutex) &gt; 0 ? 0 : -EINVAL;
00158 }
00159 
00160 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_init_rt(pthread_cond_t *cond, <span class="keyword">const</span> pthread_condattr_t *cond_attr)
00161 {
00162         <span class="keywordflow">return</span> sem_init_rt(cond, BIN_SEM, 0);
00163 }
00164 
00165 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_destroy_rt(pthread_cond_t *cond)
00166 {
00167         <span class="keywordflow">return</span> sem_destroy_rt((sem_t *)cond);
00168 }
00169 
00170 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_signal_rt(pthread_cond_t *cond)
00171 {
00172         <span class="keywordflow">return</span> rt_cond_signal((sem_t *)cond);
00173 }
00174 
00175 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_broadcast_rt(pthread_cond_t *cond)
00176 {
00177         <span class="keywordflow">return</span> rt_sem_broadcast(cond);
00178 }
00179 
00180 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_wait_rt(pthread_cond_t *cond, pthread_mutex_t *mutex)
00181 {
00182         <span class="keywordflow">return</span> rt_cond_wait(cond, mutex);
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_timedwait_rt(pthread_cond_t *cond, pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)
00186 {
00187         <span class="keywordflow">return</span> rt_cond_wait_until(cond, mutex, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -ETIMEDOUT;
00188 }
00189 
00190 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_barrier_init_rt(pthread_barrier_t *barrier, <span class="keyword">const</span> pthread_barrierattr_t *attr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count)
00191 {
00192         <span class="keywordflow">return</span> sem_init_rt(barrier, CNT_SEM, count);
00193 }
00194 
00195 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_barrier_destroy_rt(pthread_barrier_t *barrier)
00196 {
00197         <span class="keywordflow">return</span> sem_destroy_rt(barrier);
00198 }
00199 
00200 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_barrier_wait_rt(pthread_barrier_t *barrier)
00201 {
00202         <span class="keywordflow">return</span> rt_sem_wait_barrier(barrier);
00203 }
00204 
00205 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_init_rt(pthread_rwlock_t *rwlock, <span class="keyword">const</span> pthread_rwlockattr_t *attr)
00206 {
00207         <span class="keywordflow">return</span> rt_rwl_init((RWL *)rwlock);
00208 }
00209 
00210 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_destroy_rt(pthread_rwlock_t *rwlock)
00211 {
00212         <span class="keywordflow">return</span> rt_rwl_delete((RWL *)rwlock);
00213 }
00214 
00215 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_rdlock_rt(pthread_rwlock_t *rwlock)
00216 {
00217         <span class="keywordflow">return</span> rt_rwl_rdlock((RWL *)rwlock);
00218 }
00219 
00220 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_tryrdlock_rt(pthread_rwlock_t *rwlock)
00221 {
00222         <span class="keywordflow">return</span> rt_rwl_rdlock_if((RWL *)rwlock);
00223 }
00224 
00225 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_timedrdlock_rt(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime)
00226 {
00227         <span class="keywordflow">return</span> rt_rwl_rdlock_until((RWL *)rwlock, timespec2count(abstime));
00228 }
00229 
00230 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_wrlock_rt(pthread_rwlock_t *rwlock)
00231 {
00232         <span class="keywordflow">return</span> rt_rwl_wrlock((RWL *)rwlock);
00233 }
00234 
00235 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_trywrlock_rt(pthread_rwlock_t *rwlock)
00236 {
00237         <span class="keywordflow">return</span> rt_rwl_wrlock_if((RWL *)rwlock);
00238 }
00239 
00240 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_timedwrlock_rt(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime)
00241 {
00242         <span class="keywordflow">return</span> rt_rwl_wrlock_until((RWL *)rwlock, timespec2count(abstime));
00243 }
00244 
00245 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_unlock_rt(pthread_rwlock_t *rwlock)
00246 {
00247         <span class="keywordflow">return</span> rt_rwl_unlock((RWL *)rwlock);
00248 }
00249 
00250 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_init_rt(pthread_spinlock_t *lock)
00251 {
00252         <span class="keywordflow">return</span> rt_spl_init((SPL *)lock);
00253 }
00254 
00255 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_destroy_rt(pthread_spinlock_t *lock)
00256 {
00257         <span class="keywordflow">return</span> rt_spl_delete((SPL *)lock);
00258 }
00259 
00260 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_lock_rt(pthread_spinlock_t *lock)
00261 {
00262         <span class="keywordflow">return</span> rt_spl_lock((SPL *)lock);
00263 }
00264 
00265 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_trylock_rt(pthread_spinlock_t *lock)
00266 {
00267         <span class="keywordflow">return</span> rt_spl_lock_if((SPL *)lock);
00268 }
00269 
00270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_unlock_rt(pthread_spinlock_t *lock)
00271 {
00272         <span class="keywordflow">return</span> rt_spl_unlock((SPL *)lock);
00273 }
00274 
00275 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> get_max_priority_rt(<span class="keywordtype">int</span> policy)
00276 {
00277         <span class="keywordflow">return</span> MAX_PRIO;
00278 }
00279 
00280 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> get_min_priority_rt(<span class="keywordtype">int</span> policy)
00281 {
00282         <span class="keywordflow">return</span> MIN_PRIO;
00283 }
00284 
00285 <span class="keyword">static</span> <span class="keywordtype">void</span> posix_wrapper_fun(pthread_cookie_t *cookie)
00286 {
00287         cookie-&gt;task_fun(cookie-&gt;arg);
00288         rt_sem_broadcast(&amp;cookie-&gt;sem);
00289         <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(&amp;cookie-&gt;sem);
00290         <a class="code" href="common_8c.html#a9">rt_task_suspend</a>(&amp;cookie-&gt;task);
00291 } 
00292 
00293 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_create_rt(pthread_t *thread, <span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">void</span> *(*start_routine)(<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *arg)
00294 {
00295         pthread_cookie_t *cookie;
00296         cookie = (<span class="keywordtype">void</span> *)rt_malloc(<span class="keyword">sizeof</span>(pthread_cookie_t));
00297         <span class="keywordflow">if</span> (cookie) {
00298                 (cookie-&gt;task).magic = 0;
00299                 cookie-&gt;task_fun = (<span class="keywordtype">void</span> *)start_routine;
00300                 cookie-&gt;arg = (<span class="keywordtype">int</span>)arg;
00301                 <span class="keywordflow">if</span> (!<a class="code" href="sched__up_8c.html#a50">rt_task_init</a>(&amp;cookie-&gt;task, (<span class="keywordtype">void</span> *)posix_wrapper_fun, (<span class="keywordtype">int</span>)cookie, attr-&gt;stacksize, attr-&gt;priority, 1, 0)) {
00302                         *thread = &amp;cookie-&gt;task;
00303                         <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(&amp;cookie-&gt;sem, 0, BIN_SEM | FIFO_Q);
00304                         <a class="code" href="common_8c.html#a10">rt_task_resume</a>(&amp;cookie-&gt;task);
00305                         <span class="keywordflow">return</span> 0;
00306                 }
00307         }
00308         rt_free(cookie);
00309         <span class="keywordflow">return</span> ENOMEM;
00310 }
00311 
00312 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_yield_rt(<span class="keywordtype">void</span>)
00313 {
00314         <a class="code" href="group__lxrt.html#a8">rt_task_yield</a>();
00315         <span class="keywordflow">return</span> 0;
00316 }
00317 
00318 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> pthread_exit_rt(<span class="keywordtype">void</span> *retval)
00319 {
00320         RT_TASK *rt_task;
00321         rt_task = <a class="code" href="common_8c.html#a7">rt_whoami</a>();
00322         rt_sem_broadcast((SEM *)(rt_task + 1));
00323         <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>((SEM *)(rt_task + 1));
00324         <a class="code" href="common_8c.html#a9">rt_task_suspend</a>(rt_task);
00325 }
00326 
00327 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_join_rt(pthread_t thread, <span class="keywordtype">void</span> **thread_return)
00328 {
00329         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>((SEM *)(thread + 1));
00330 }
00331 
00332 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cancel_rt(pthread_t thread)
00333 {
00334         <span class="keywordtype">int</span> retval;
00335         <span class="keywordflow">if</span> (!thread) {
00336                 thread = <a class="code" href="common_8c.html#a7">rt_whoami</a>();
00337         }
00338         retval = <a class="code" href="sched__up_8c.html#a61">rt_task_delete</a>(thread);
00339         rt_free(thread);
00340         <span class="keywordflow">return</span> retval;
00341 }
00342 
00343 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_equal_rt(pthread_t thread1,pthread_t thread2)
00344 {
00345         <span class="keywordflow">return</span> thread1 == thread2;
00346 }
00347 
00348 <span class="keyword">static</span> <span class="keyword">inline</span> pthread_t pthread_self_rt(<span class="keywordtype">void</span>)
00349 {
00350         <span class="keywordflow">return</span> <a class="code" href="common_8c.html#a7">rt_whoami</a>();
00351 }
00352 
00353 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_init_rt(pthread_attr_t *attr)
00354 {
00355         attr-&gt;stacksize     = STACK_SIZE;
00356         attr-&gt;policy        = SCHED_FIFO;
00357         attr-&gt;rr_quantum_ns = RR_QUANTUM_NS;
00358         attr-&gt;priority      = 1;
00359         <span class="keywordflow">return</span> 0;
00360 }
00361 
00362 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_destroy_rt(pthread_attr_t *attr)
00363 {
00364         <span class="keywordflow">return</span> 0;
00365 }
00366 
00367 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setschedparam_rt(pthread_attr_t *attr, <span class="keyword">const</span> <span class="keyword">struct</span> sched_param *param)
00368 {
00369         <span class="keywordflow">if</span>(param-&gt;sched_priority &lt; MIN_PRIO || param-&gt;sched_priority &gt; MAX_PRIO) {
00370                 <span class="keywordflow">return</span>(EINVAL);
00371         }
00372         attr-&gt;priority = MAX_PRIO - param-&gt;sched_priority;
00373         <span class="keywordflow">return</span> 0;
00374 }
00375 
00376 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getschedparam_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keyword">struct</span> sched_param *param)
00377 {
00378         param-&gt;sched_priority = MAX_PRIO - attr-&gt;priority;
00379         <span class="keywordflow">return</span> 0;
00380 }
00381 
00382 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setschedpolicy_rt(pthread_attr_t *attr, <span class="keywordtype">int</span> policy)
00383 {
00384         <span class="keywordflow">if</span>(policy != SCHED_FIFO &amp;&amp; policy != SCHED_RR) {
00385                 <span class="keywordflow">return</span> EINVAL;
00386         }
00387         <span class="keywordflow">if</span> ((attr-&gt;policy = policy) == SCHED_RR) {
00388                 rt_set_sched_policy(<a class="code" href="common_8c.html#a7">rt_whoami</a>(), SCHED_RR, attr-&gt;rr_quantum_ns);
00389         }
00390         <span class="keywordflow">return</span> 0;
00391 }
00392 
00393 
00394 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getschedpolicy_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">int</span> *policy)
00395 {
00396         *policy = attr-&gt;policy;
00397         <span class="keywordflow">return</span> 0;
00398 }
00399 
00400 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setschedrr_rt(pthread_attr_t *attr, <span class="keywordtype">int</span> rr_quantum_ns)
00401 {
00402         attr-&gt;rr_quantum_ns = rr_quantum_ns;
00403         <span class="keywordflow">return</span> 0;
00404 }
00405 
00406 
00407 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getschedrr_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">int</span> *rr_quantum_ns)
00408 {
00409         *rr_quantum_ns = attr-&gt;rr_quantum_ns;
00410         <span class="keywordflow">return</span> 0;
00411 }
00412 
00413 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setstacksize_rt(pthread_attr_t *attr, <span class="keywordtype">int</span> stacksize)
00414 {
00415         attr-&gt;stacksize = stacksize;
00416         <span class="keywordflow">return</span> 0;
00417 }
00418 
00419 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getstacksize_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">int</span> *stacksize)
00420 {
00421         *stacksize = attr-&gt;stacksize;
00422         <span class="keywordflow">return</span> 0;
00423 }
00424 
00425 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setstack_rt(pthread_attr_t *attr, <span class="keywordtype">void</span> *stackaddr, <span class="keywordtype">int</span> stacksize)
00426 {
00427         attr-&gt;stacksize = stacksize;
00428         <span class="keywordflow">return</span> 0;
00429 }
00430 
00431 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getstack_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">void</span> **stackaddr, <span class="keywordtype">int</span> *stacksize)
00432 {
00433         *stacksize = attr-&gt;stacksize;
00434         <span class="keywordflow">return</span> 0;
00435 }
00436 
00437 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> pthread_testcancel_rt(<span class="keywordtype">void</span>)
00438 {
00439         <a class="code" href="sched__up_8c.html#a61">rt_task_delete</a>(<a class="code" href="common_8c.html#a7">rt_whoami</a>());
00440         pthread_exit_rt(NULL);
00441 }
00442 
00443 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> clock_gettime_rt(<span class="keywordtype">int</span> clockid, <span class="keyword">struct</span> timespec *current_time)
00444 {
00445         count2timespec(<a class="code" href="group__lxrt.html#a19">rt_get_time</a>(), current_time);
00446 }
00447 
00448 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> nanosleep_rt(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *rqtp, <span class="keyword">struct</span> timespec *rmtp)
00449 {
00450         RTIME expire;
00451         <span class="keywordflow">if</span> (rqtp-&gt;tv_nsec &gt;= 1000000000L || rqtp-&gt;tv_nsec &lt; 0 || rqtp-&gt;tv_sec &lt;
00452 0) {
00453                 <span class="keywordflow">return</span> -EINVAL;
00454         }
00455         <a class="code" href="common_8c.html#a25">rt_sleep_until</a>(expire = <a class="code" href="group__lxrt.html#a19">rt_get_time</a>() + timespec2count(rqtp));
00456         <span class="keywordflow">if</span> ((expire -= <a class="code" href="group__lxrt.html#a19">rt_get_time</a>()) &gt; 0) {
00457                 <span class="keywordflow">if</span> (rmtp) {
00458                         count2timespec(expire, rmtp);
00459                 }
00460                 <span class="keywordflow">return</span> -EINTR;
00461         }
00462         <span class="keywordflow">return</span> 0;
00463 }
00464 
00465 <span class="comment">/*</span>
00466 <span class="comment"> * DO NOTHING FUNCTIONS</span>
00467 <span class="comment"> */</span>
00468 
00469 <span class="preprocessor">#define pthread_mutexattr_init_rt(attr)</span>
00470 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_destroy_rt(attr)</span>
00471 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_getpshared_rt(attr, pshared)</span>
00472 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_setpshared_rt(attr, pshared)</span>
00473 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_settype_rt(attr, kind)</span>
00474 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_gettype_rt(attr, kind)</span>
00475 <span class="preprocessor"></span>
00476 <span class="preprocessor">#define pthread_condattr_init_rt(attr)</span>
00477 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_destroy_rt(attr)</span>
00478 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_getpshared_rt(attr, pshared)</span>
00479 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_setpshared_rt(attr, pshared)</span>
00480 <span class="preprocessor"></span>
00481 <span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00482 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00483 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00484 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00485 <span class="preprocessor"></span>
00486 <span class="preprocessor">#define pthread_rwlockattr_init(attr)</span>
00487 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_destroy(attr)</span>
00488 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getpshared( ttr, pshared)</span>
00489 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setpshared(attr, pshared)</span>
00490 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getkind_np(attr, pref)</span>
00491 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setkind_np(attr, pref)</span>
00492 <span class="preprocessor"></span>
00493 <span class="preprocessor">#define pthread_detach_rt(thread)</span>
00494 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setdetachstate_rt(attr, detachstate)</span>
00495 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getdetachstate_rt(attr, detachstate)</span>
00496 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setconcurrency_rt(level)</span>
00497 <span class="preprocessor"></span><span class="preprocessor">#define pthread_getconcurrency_rt()</span>
00498 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setinheritsched_rt(attr, inherit)</span>
00499 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getinheritsched_rt(attr, inherit)</span>
00500 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setscope_rt(attr, scope)</span>
00501 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getscope_rt(attr, scope)</span>
00502 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setguardsize_rt(attr, guardsize) </span>
00503 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getguardsize_rt(attr, guardsize)</span>
00504 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstackaddr_rt(attr, stackaddr)</span>
00505 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstackaddr_rt(attr, stackaddr) </span>
00506 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setcancelstate_rt(state, oldstate)</span>
00507 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setcanceltype_rt(type, oldtype)</span>
00508 <span class="preprocessor"></span>
00509 <span class="preprocessor">#ifdef __cplusplus</span>
00510 <span class="preprocessor"></span>}
00511 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00512 
00513 <span class="preprocessor">#else  </span><span class="comment">/* !__KERNEL__ */</span>
00514 
00515 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00516 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00517 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00518 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00519 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00520 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00521 <span class="preprocessor">#include &lt;semaphore.h&gt;</span>
00522 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00523 
00524 <span class="keyword">struct </span>task_struct;
00525 
00526 <span class="preprocessor">#undef  SEM_VALUE_MAX </span>
00527 <span class="preprocessor"></span><span class="preprocessor">#define SEM_VALUE_MAX  (SEM_TIMOUT - 1)</span>
00528 <span class="preprocessor"></span><span class="preprocessor">#define SEM_BINARY     (0x7FFFFFFF)</span>
00529 <span class="preprocessor"></span>
00530 <span class="preprocessor">#include &lt;asm/rtai_atomic.h&gt;</span>
00531 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00532 
00533 <span class="comment">/*</span>
00534 <span class="comment"> * SUPPORT STUFF</span>
00535 <span class="comment"> */</span>
00536 
00537 <span class="keyword">typedef</span> <span class="keyword">struct </span>pthread_barrier {
00538 
00539     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data[2];
00540 
00541 } pthread_barrier_t;
00542 
00543 <span class="keyword">typedef</span> <span class="keywordtype">int</span> pthread_barrierattr_t;
00544 
00545 <span class="keyword">typedef</span> <span class="keyword">struct </span>pthread_rwlock {
00546 
00547     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data[2];
00548 
00549 } pthread_rwlock_t;
00550 
00551 <span class="keyword">typedef</span> <span class="keywordtype">int</span> pthread_rwlockattr_t;
00552 
00553 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pthread_spinlock_t;
00554 
00555 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> MAKE_SOFT(<span class="keywordtype">void</span>)
00556 {
00557         <span class="keywordflow">if</span> (rt_is_hard_real_time(rt_buddy())) {
00558                 <a class="code" href="group__lxrt.html#a6">rt_make_soft_real_time</a>();
00559                 <span class="keywordflow">return</span> 1;
00560         }
00561         <span class="keywordflow">return</span> 0;
00562 }
00563 
00564 <span class="preprocessor">#define MAKE_HARD(hs)  do { if (hs) rt_make_hard_real_time(); } while (0)</span>
00565 <span class="preprocessor"></span>
00566 <span class="preprocessor">#ifdef __cplusplus</span>
00567 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00568 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00569 
00570 RTAI_PROTO(<span class="keywordtype">void</span>, count2timespec,(RTIME rt, <span class="keyword">struct</span> timespec *t))
00571 {
00572         t-&gt;tv_sec = (rt = <a class="code" href="sched__up_8c.html#a90">count2nano</a>(rt))/1000000000;
00573         t-&gt;tv_nsec = rt - t-&gt;tv_sec*1000000000LL;
00574 }
00575 
00576 RTAI_PROTO(<span class="keywordtype">void</span>, nanos2timespec,(RTIME rt, <span class="keyword">struct</span> timespec *t))
00577 {
00578         t-&gt;tv_sec = rt/1000000000;
00579         t-&gt;tv_nsec = rt - t-&gt;tv_sec*1000000000LL;
00580 }
00581 
00582 RTAI_PROTO(RTIME, timespec2count,(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t))
00583 {
00584         <span class="keywordflow">return</span> <a class="code" href="sched__up_8c.html#a91">nano2count</a>(t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec);
00585 }
00586 
00587 RTAI_PROTO(RTIME, timespec2nanos,(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t))
00588 {
00589         <span class="keywordflow">return</span> t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec;
00590 }
00591 
00592 <span class="comment">/*</span>
00593 <span class="comment"> * FUNCTIONS MADE SAFELY USABLE IN HARD REAL TIME, BUT BREAKING HARD REAL TIME</span>
00594 <span class="comment"> */</span>
00595 
00596 RTAI_PROTO(sem_t *,sem_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> oflags, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00597 {
00598         <span class="keywordtype">int</span> hs, fd;
00599         sem_t *sem;
00600         hs = MAKE_SOFT();
00601         <span class="keywordflow">if</span> ((fd = open(name, O_RDONLY)) &gt; 0) {
00602                 read(fd, &amp;sem, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00603                 close(fd); 
00604                 atomic_inc((atomic_t *)(&amp;((<span class="keywordtype">int</span> *)sem)[1]));
00605         } <span class="keywordflow">else</span> {
00606                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), value, (type == SEM_BINARY ? BIN_SEM : CNT_SEM) | PRIO_Q };
00607                 sem = (sem_t *)malloc(<span class="keyword">sizeof</span>(sem_t));
00608                 <span class="keywordflow">if</span> ((((<span class="keywordtype">int</span> *)sem)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW]) &amp;&amp; (fd = open(name, O_WRONLY | O_CREAT))) {
00609                         write(fd, &amp;sem, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00610                         close(fd); 
00611                         ((<span class="keywordtype">int</span> *)sem)[1] = 1;
00612                 } <span class="keywordflow">else</span> {
00613                         free(sem);
00614                         sem = 0;
00615                 }
00616         }
00617         MAKE_HARD(hs);
00618         <span class="keywordflow">return</span> sem;
00619 }
00620 
00621 RTAI_PROTO(<span class="keywordtype">int</span>, sem_init_rt,(sem_t *sem, <span class="keywordtype">int</span> pshared, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value))
00622 {
00623         <span class="keywordtype">int</span> hs;
00624         <span class="keywordflow">if</span> (value &lt;= SEM_VALUE_MAX) {
00625                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="group__lxrt.html#a54">rt_get_name</a>(0), value, (pshared == SEM_BINARY ? BIN_SEM : CNT_SEM) | PRIO_Q };
00626                 hs = MAKE_SOFT();
00627                 ((<span class="keywordtype">int</span> *)sem)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW];
00628                 ((<span class="keywordtype">int</span> *)sem)[1] = 0;
00629                 MAKE_HARD(hs);
00630                 <span class="keywordflow">return</span> 0;
00631         }
00632         errno = EINVAL;
00633         <span class="keywordflow">return</span> -1;
00634 }
00635 
00636 RTAI_PROTO(<span class="keywordtype">int</span>, sem_close_rt,(sem_t *sem))
00637 {
00638         <span class="keywordtype">int</span> hs, cnt;
00639         <span class="keywordtype">char</span> name[7];
00640         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00641         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW] &lt; 0) {
00642                 errno = EBUSY;
00643                 <span class="keywordflow">return</span> -1;
00644         }
00645         cnt = ((<span class="keywordtype">int</span> *)sem)[1];
00646         <span class="keywordflow">if</span> (!cnt || (cnt &amp;&amp; atomic_dec_and_test((atomic_t *)&amp;((<span class="keywordtype">int</span> *)sem)[1]))) {
00647                 hs = MAKE_SOFT();
00648                 <a class="code" href="rtai__nam2num_8h.html#a1">num2nam</a>(<a class="code" href="group__lxrt.html#a54">rt_get_name</a>(((<span class="keywordtype">void</span> **)sem)[0]), name);
00649                 rtai_lxrt(BIDX, SIZARG, SEM_DELETE, &amp;arg);
00650                 <span class="keywordflow">if</span> (cnt) {
00651                         unlink(name);
00652                         free((<span class="keywordtype">void</span> *)sem);
00653                 }
00654                 MAKE_HARD(hs);
00655         }
00656         <span class="keywordflow">return</span> 0;
00657 }
00658 
00659 RTAI_PROTO(<span class="keywordtype">int</span>, sem_destroy_rt,(sem_t *sem))
00660 {
00661         <span class="keywordflow">return</span> sem_close_rt(sem);
00662 }
00663 
00664 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_create_rt,(pthread_t *thread, pthread_attr_t *attr, <span class="keywordtype">void</span> *(*start_routine)(<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *arg))
00665 {
00666         <span class="keywordtype">int</span> hs, ret;
00667         hs = MAKE_SOFT();
00668         ret = pthread_create(thread, attr, start_routine, arg);
00669         MAKE_HARD(hs);
00670         <span class="keywordflow">return</span> ret;
00671 }
00672 
00673 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cancel_rt,(pthread_t thread))
00674 {
00675         <span class="keywordtype">int</span> hs, ret;
00676         hs = MAKE_SOFT();
00677         ret = pthread_cancel(thread);
00678         MAKE_HARD(hs);
00679         <span class="keywordflow">return</span> ret;
00680 }
00681 
00682 <span class="preprocessor">#define pthread_cleanup_push_rt(routine, arg) \</span>
00683 <span class="preprocessor">do { \</span>
00684 <span class="preprocessor">        {\</span>
00685 <span class="preprocessor">                int __hs_hs_hs__; \</span>
00686 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00687 <span class="preprocessor">                pthread_cleanup_push(routine, arg); \</span>
00688 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__);</span>
00689 <span class="preprocessor"></span>        
00690 <span class="preprocessor">#define pthread_cleanup_pop_rt(execute) \</span>
00691 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00692 <span class="preprocessor">                pthread_cleanup_pop(execute); \</span>
00693 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__); \</span>
00694 <span class="preprocessor">        } \</span>
00695 <span class="preprocessor">} while (0)</span>
00696 <span class="preprocessor"></span>
00697 <span class="preprocessor">#define pthread_cleanup_push_defer_rt(routine, arg) \</span>
00698 <span class="preprocessor">do { \</span>
00699 <span class="preprocessor">        {\</span>
00700 <span class="preprocessor">                int __hs_hs_hs__; \</span>
00701 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00702 <span class="preprocessor">                pthread_cleanup_push_defer_np(routine, arg); \</span>
00703 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__);</span>
00704 <span class="preprocessor"></span>
00705 <span class="preprocessor">#define pthread_cleanup_pop_restore_rt(execute) \</span>
00706 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00707 <span class="preprocessor">                pthread_cleanup_pop_restore_np(execute); \</span>
00708 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__); \</span>
00709 <span class="preprocessor">        } \</span>
00710 <span class="preprocessor">} while (0)</span>
00711 <span class="preprocessor"></span>
00712 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_sigmask_rt,(<span class="keywordtype">int</span> how, <span class="keyword">const</span> sigset_t *newmask, sigset_t *oldmask))
00713 {
00714         <span class="keywordtype">int</span> hs, ret;
00715         hs = MAKE_SOFT();
00716         ret = pthread_sigmask(how, newmask, oldmask);
00717         MAKE_HARD(hs);
00718         <span class="keywordflow">return</span> ret;
00719 }
00720 
00721 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_kill_rt,(pthread_t thread, <span class="keywordtype">int</span> signo))
00722 {
00723         <span class="keywordtype">int</span> hs, ret;
00724         hs = MAKE_SOFT();
00725         ret = pthread_kill(thread, signo);
00726         MAKE_HARD(hs);
00727         <span class="keywordflow">return</span> ret;
00728 }
00729 
00730 
00731 RTAI_PROTO(<span class="keywordtype">int</span>, sigwait_rt,(<span class="keyword">const</span> sigset_t *set, <span class="keywordtype">int</span> *sig))
00732 {
00733         <span class="keywordtype">int</span> hs, ret;
00734         hs = MAKE_SOFT();
00735         ret = sigwait(set, sig);
00736         MAKE_HARD(hs);
00737         <span class="keywordflow">return</span> ret;
00738 }
00739 
00740 RTAI_PROTO(pthread_mutex_t *, pthread_mutex_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00741 {
00742         <span class="keywordtype">int</span> hs, fd;
00743         pthread_mutex_t *mutex;
00744         hs = MAKE_SOFT();
00745         <span class="keywordflow">if</span> ((fd = open(name, O_RDONLY)) &gt; 0) {
00746                 read(fd, &amp;mutex, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00747                 close(fd); 
00748                 atomic_inc((atomic_t *)(&amp;((<span class="keywordtype">int</span> *)mutex)[1]));
00749         } <span class="keywordflow">else</span> {
00750                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), 1, RES_SEM };
00751                 mutex = (pthread_mutex_t *)malloc(<span class="keyword">sizeof</span>(pthread_mutex_t));
00752                 <span class="keywordflow">if</span> ((((<span class="keywordtype">int</span> *)mutex)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW]) &amp;&amp; (fd = open(name, O_WRONLY | O_CREAT))) {
00753                         write(fd, &amp;mutex, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00754                         close(fd); 
00755                         ((<span class="keywordtype">int</span> *)mutex)[1] = 1;
00756                 } <span class="keywordflow">else</span> {
00757                         free(mutex);
00758                         mutex = 0;
00759                 }
00760         }
00761         MAKE_HARD(hs);
00762         <span class="keywordflow">return</span> mutex;
00763 }
00764 
00765 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_init_rt,(pthread_mutex_t *mutex, <span class="keyword">const</span> pthread_mutexattr_t *mutexattr))
00766 {
00767         <span class="keywordtype">int</span> hs;
00768         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="group__lxrt.html#a54">rt_get_name</a>(0), 1, RES_SEM };
00769         hs = MAKE_SOFT();
00770         ((<span class="keywordtype">int</span> *)mutex)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW];
00771         ((<span class="keywordtype">int</span> *)mutex)[1] = 0;
00772         MAKE_HARD(hs);
00773         <span class="keywordflow">return</span> 0;
00774 }
00775 
00776 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_close_rt,(pthread_mutex_t *mutex))
00777 {
00778         <span class="keywordtype">int</span> hs, cnt;
00779         <span class="keywordtype">char</span> name[7];
00780         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)mutex)[0] };
00781         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW] &lt; 0) {
00782                 <span class="keywordflow">return</span> EBUSY;
00783         }
00784         cnt = ((<span class="keywordtype">int</span> *)mutex)[1];
00785         <span class="keywordflow">if</span> (!cnt || (cnt &amp;&amp; atomic_dec_and_test((atomic_t *)&amp;((<span class="keywordtype">int</span> *)mutex)[1]))) {
00786                 hs = MAKE_SOFT();
00787                 <a class="code" href="rtai__nam2num_8h.html#a1">num2nam</a>(<a class="code" href="group__lxrt.html#a54">rt_get_name</a>(((<span class="keywordtype">void</span> **)mutex)[0]), name);
00788                 rtai_lxrt(BIDX, SIZARG, SEM_DELETE, &amp;arg);
00789                 <span class="keywordflow">if</span> (cnt) {
00790                         unlink(name);
00791                         free((<span class="keywordtype">void</span> *)mutex);
00792                 }
00793                 MAKE_HARD(hs);
00794         }
00795         <span class="keywordflow">return</span> 0;
00796 }
00797 
00798 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_destroy_rt,(pthread_mutex_t *mutex))
00799 {
00800         <span class="keywordflow">return</span> pthread_mutex_close_rt(mutex);
00801 }
00802 
00803 RTAI_PROTO(pthread_cond_t *, pthread_cond_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00804 {
00805         <span class="keywordflow">return</span> (pthread_cond_t *)sem_open_rt(name, 0, 0, SEM_BINARY);
00806 }
00807 
00808 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_init_rt,(pthread_cond_t *cond, pthread_condattr_t *cond_attr))
00809 {
00810         <span class="keywordflow">return</span> sem_init_rt((sem_t *)cond, SEM_BINARY, 0);
00811 }
00812 
00813 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_destroy_rt,(pthread_cond_t *cond))
00814 {
00815         <span class="keywordflow">return</span> sem_close_rt((sem_t *)cond);
00816 }
00817 
00818 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_close_rt,(pthread_cond_t *cond))
00819 {
00820         <span class="keywordflow">return</span> sem_close_rt((sem_t *)cond);
00821 }
00822 
00823 RTAI_PROTO(pthread_barrier_t *, pthread_barrier_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count))
00824 {
00825         <span class="keywordflow">return</span> (pthread_barrier_t *)sem_open_rt(name, 0, count, 0);
00826 }
00827 
00828 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_init_rt,(pthread_barrier_t *barrier, <span class="keyword">const</span> pthread_barrierattr_t *attr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count))
00829 {
00830         <span class="keywordflow">return</span> sem_init_rt((sem_t *)barrier, 0, count);
00831 }
00832 
00833 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_destroy_rt,(pthread_barrier_t *barrier))
00834 {
00835         <span class="keywordflow">return</span> sem_close_rt((sem_t *)barrier);
00836 }
00837 
00838 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_close_rt,(pthread_barrier_t *barrier))
00839 {
00840         <span class="keywordflow">return</span> sem_close_rt((sem_t *)barrier);
00841 }
00842 
00843 <span class="comment">/*</span>
00844 <span class="comment"> * DO NOTHING FUNCTIONS (IN RTAI HARD REAL TIME)</span>
00845 <span class="comment"> */</span>
00846 
00847 <span class="preprocessor">#define pthread_attr_setdetachstate_rt(attr, detachstate)</span>
00848 <span class="preprocessor"></span><span class="preprocessor">#define pthread_detach_rt(thread)</span>
00849 <span class="preprocessor"></span><span class="preprocessor">#define pthread_getconcurrency_rt()</span>
00850 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setconcurrency_rt(level)</span>
00851 <span class="preprocessor"></span>
00852 <span class="preprocessor">#define pthread_mutexattr_init_rt(attr)</span>
00853 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_destroy_rt(attr)</span>
00854 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_getpshared_rt(attr, pshared)</span>
00855 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_setpshared_rt(attr, pshared)</span>
00856 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_settype_rt(attr, kind)</span>
00857 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_gettype_rt(attr, kind)</span>
00858 <span class="preprocessor"></span>
00859 <span class="preprocessor">#define pthread_condattr_init_rt(attr)</span>
00860 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_destroy_rt(attr)</span>
00861 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_getpshared_rt(attr, pshared)</span>
00862 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_setpshared_rt(attr, pshared)</span>
00863 <span class="preprocessor"></span>
00864 <span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00865 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00866 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00867 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00868 <span class="preprocessor"></span>
00869 <span class="preprocessor">#define pthread_rwlockattr_init(attr)</span>
00870 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_destroy(attr)</span>
00871 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getpshared( ttr, pshared)</span>
00872 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setpshared(attr, pshared)</span>
00873 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getkind_np(attr, pref)</span>
00874 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setkind_np(attr, pref)</span>
00875 <span class="preprocessor"></span>
00876 <span class="comment">/*</span>
00877 <span class="comment"> * FUNCTIONS (LIKELY) SAFELY USABLE IN HARD REAL TIME "AS THEY ARE", </span>
00878 <span class="comment"> * BECAUSE MAKE SENSE IN THE INITIALIZATION PHASE ONLY, I.E. BEFORE </span>
00879 <span class="comment"> * GOING HARD REAL TIME</span>
00880 <span class="comment"> */</span>
00881 
00882 <span class="preprocessor">#define pthread_self_rt                  pthread_self</span>
00883 <span class="preprocessor"></span><span class="preprocessor">#define pthread_equal_rt                 pthread_equal</span>
00884 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_init_rt             pthread_attr_init      </span>
00885 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_destroy_rt          pthread_attr_destroy</span>
00886 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getdetachstate_rt   pthread_attr_getdetachstate</span>
00887 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setschedpolicy_rt   pthread_attr_setschedpolicy</span>
00888 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getschedpolicy_rt   pthread_attr_getschedpolicy </span>
00889 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setschedparam_rt    pthread_attr_setschedparam</span>
00890 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getschedparam_rt    pthread_attr_getschedparam</span>
00891 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setinheritsched_rt  pthread_attr_setinheritsched</span>
00892 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getinheritsched_rt  pthread_attr_getinheritsched</span>
00893 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setscope_rt         pthread_attr_setscope</span>
00894 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getscope_rt         pthread_attr_getscope</span>
00895 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setguardsize_rt     pthread_attr_setguardsize</span>
00896 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getguardsize_rt     pthread_attr_getguardsize</span>
00897 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstackaddr_rt     pthread_attr_setstackaddr</span>
00898 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstackaddr_rt     pthread_attr_getstackaddr</span>
00899 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstack_rt         pthread_attr_setstack</span>
00900 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstack_rt         pthread_attr_getstack</span>
00901 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstacksize_rt     pthread_attr_setstacksize</span>
00902 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstacksize_rt     pthread_attr_getstacksize</span>
00903 <span class="preprocessor"></span>
00904 <span class="comment">/*</span>
00905 <span class="comment"> * WORKING FUNCTIONS USABLE IN HARD REAL TIME, THIS IS THE REAL STUFF</span>
00906 <span class="comment"> */</span>
00907 
00908 <span class="preprocessor">#define pthread_setcancelstate_rt  pthread_setcancelstate</span>
00909 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setcanceltype_rt   pthread_setcanceltype</span>
00910 <span class="preprocessor"></span>
00911 RTAI_PROTO(<span class="keywordtype">void</span>, pthread_testcancel_rt,(<span class="keywordtype">void</span>))
00912 {
00913         <span class="keywordtype">int</span> oldtype, oldstate;
00914         pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;oldstate);
00915         pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &amp;oldtype);
00916         <span class="keywordflow">if</span> (oldstate != PTHREAD_CANCEL_DISABLE &amp;&amp; oldtype != PTHREAD_CANCEL_DEFERRED) {
00917                 MAKE_SOFT();
00918                 <a class="code" href="sched__up_8c.html#a61">rt_task_delete</a>(rt_buddy());
00919                 pthread_exit(NULL);
00920         }
00921         pthread_setcanceltype(oldtype, &amp;oldtype);
00922         pthread_setcancelstate(oldstate, &amp;oldstate);
00923 }
00924 
00925 <span class="keyword">extern</span> <span class="keywordtype">int</span> pthread_yield (<span class="keywordtype">void</span>);
00926 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_yield_rt,(<span class="keywordtype">void</span>))
00927 {
00928         <span class="keywordflow">if</span> (rt_is_hard_real_time(rt_buddy())) {
00929                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00930                 rtai_lxrt(BIDX, SIZARG, YIELD, &amp;arg);
00931                 <span class="keywordflow">return</span> 0;
00932         }
00933         <span class="keywordflow">return</span> pthread_yield();
00934 }
00935 
00936 RTAI_PROTO(<span class="keywordtype">void</span>, pthread_exit_rt,(<span class="keywordtype">void</span> *retval))
00937 {
00938         MAKE_SOFT();
00939         <a class="code" href="sched__up_8c.html#a61">rt_task_delete</a>(rt_buddy());
00940         pthread_exit(retval);
00941 }
00942 
00943 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_join_rt,(pthread_t thread, <span class="keywordtype">void</span> **thread_return))
00944 {
00945         <span class="keywordtype">int</span> hs, ret;
00946         hs = MAKE_SOFT();
00947         ret = pthread_join(thread, thread_return);
00948         MAKE_HARD(hs);
00949         <span class="keywordflow">return</span> ret;
00950 }
00951 
00952 RTAI_PROTO(<span class="keywordtype">int</span>, sem_wait_rt,(sem_t *sem))
00953 {
00954         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00955         rtai_lxrt(BIDX, SIZARG, SEM_WAIT, &amp;arg);
00956         <span class="keywordflow">return</span> 0;
00957 }
00958 
00959 RTAI_PROTO(<span class="keywordtype">int</span>, sem_trywait_rt,(sem_t *sem))
00960 {
00961         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00962         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW] &gt; 0) {
00963                 <span class="keywordflow">return</span> 0;
00964         }
00965         errno = EAGAIN;
00966         <span class="keywordflow">return</span> -1;
00967 }
00968 
00969 RTAI_PROTO(<span class="keywordtype">int</span>, sem_timedwait_rt,(sem_t *sem, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime))
00970 {
00971         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; RTIME until; } arg = { ((<span class="keywordtype">void</span> **)sem)[0], timespec2count(abstime) };
00972         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_UNTIL, &amp;arg).i[LOW] &lt; SEM_VALUE_MAX ? 0 : ETIMEDOUT;
00973 }
00974 
00975 RTAI_PROTO(<span class="keywordtype">int</span>, sem_post_rt,(sem_t *sem))
00976 {
00977         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00978         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_SIGNAL, &amp;arg).i[LOW];
00979 }
00980 
00981 <span class="keyword">extern</span> <span class="keywordtype">int</span> sem_getvalue_rt(sem_t *sem, <span class="keywordtype">int</span> *sval)
00982 {
00983         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00984         *sval = rtai_lxrt(BIDX, SIZARG, SEM_COUNT, &amp;arg).i[LOW];
00985         <span class="keywordflow">return</span> 0;
00986 }
00987 
00988 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_lock_rt,(pthread_mutex_t *mutex))
00989 {
00990         <span class="keywordflow">return</span> sem_wait_rt((sem_t *)mutex);
00991 }
00992 
00993 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_timedlock_rt,(pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime))
00994 {
00995         <span class="keywordflow">return</span> sem_timedwait_rt((sem_t *)mutex, abstime);
00996 }
00997 
00998 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_trylock_rt,(pthread_mutex_t *mutex))
00999 {
01000         <span class="keywordflow">return</span> sem_trywait_rt((sem_t *)mutex);
01001 }
01002 
01003 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_unlock_rt,(pthread_mutex_t *mutex))
01004 {
01005         <span class="keywordflow">return</span> sem_post_rt((sem_t *)mutex);
01006 }
01007 
01008 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_signal_rt,(pthread_cond_t *cond))
01009 {
01010         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; } arg = { ((<span class="keywordtype">void</span> **)cond)[0] };
01011         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_SIGNAL, &amp;arg).i[LOW];
01012 }
01013 
01014 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_broadcast_rt,(pthread_cond_t *cond))
01015 {
01016         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; } arg = { ((<span class="keywordtype">void</span> **)cond)[0] };
01017         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_BROADCAST, &amp;arg).i[LOW];
01018 }
01019 
01020 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_wait_rt,(pthread_cond_t *cond, pthread_mutex_t *mutex))
01021 {
01022         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; <span class="keywordtype">void</span> *mutex; } arg = { ((<span class="keywordtype">void</span> **)cond)[0], ((<span class="keywordtype">void</span> **)mutex)[0] };
01023         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT, &amp;arg).i[LOW];
01024 }
01025 
01026 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_timedwait_rt,(pthread_cond_t *cond, pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime))
01027 {
01028         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; <span class="keywordtype">void</span> *mutex; RTIME time; } arg = { ((<span class="keywordtype">void</span> **)cond)[0], ((<span class="keywordtype">void</span> **)mutex)[0], timespec2count(abstime) };
01029         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_UNTIL, &amp;arg).i[LOW] &lt; SEM_TIMOUT ? 0 : -ETIMEDOUT;
01030 }
01031 
01032 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_wait_rt,(pthread_barrier_t *barrier))
01033 {
01034         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)barrier)[0] };
01035         rtai_lxrt(BIDX, SIZARG, SEM_WAIT_BARRIER, &amp;arg);
01036         <span class="keywordflow">return</span> 0;
01037 }
01038 
01039 RTAI_PROTO(pthread_rwlock_t *, pthread_rwlock_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
01040 {
01041         <span class="keywordtype">int</span> hs, fd;
01042         pthread_rwlock_t *rwlock;
01043         hs = MAKE_SOFT();
01044         <span class="keywordflow">if</span> ((fd = open(name, O_RDONLY)) &gt; 0) {
01045                 read(fd, &amp;rwlock, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01046                 close(fd); 
01047                 atomic_inc((atomic_t *)(&amp;((<span class="keywordtype">int</span> *)rwlock)[1]));
01048         } <span class="keywordflow">else</span> {
01049                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), 1, RES_SEM };
01050                 rwlock = (pthread_rwlock_t *)malloc(<span class="keyword">sizeof</span>(pthread_rwlock_t));
01051                 <span class="keywordflow">if</span> ((((<span class="keywordtype">int</span> *)rwlock)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_RWL_INIT, &amp;arg).i[LOW]) &amp;&amp; (fd = open(name, O_WRONLY | O_CREAT))) {
01052                         write(fd, &amp;rwlock, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01053                         close(fd); 
01054                         ((<span class="keywordtype">int</span> *)rwlock)[1] = 1;
01055                 } <span class="keywordflow">else</span> {
01056                         free(rwlock);
01057                         rwlock = 0;
01058                 }
01059         }
01060         MAKE_HARD(hs);
01061         <span class="keywordflow">return</span> rwlock;
01062 }
01063 
01064 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_init_rt,(pthread_rwlock_t *rwlock, pthread_rwlockattr_t *attr))
01065 {
01066         <span class="keywordtype">int</span> hs;
01067         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { <a class="code" href="group__lxrt.html#a54">rt_get_name</a>(0) };
01068         hs = MAKE_SOFT();
01069         ((<span class="keywordtype">int</span> *)rwlock)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_RWL_INIT, &amp;arg).i[LOW];
01070         ((<span class="keywordtype">int</span> *)rwlock)[1] = 0;
01071         MAKE_HARD(hs);
01072         <span class="keywordflow">return</span> 0;
01073 }
01074 
01075 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_close_rt,(pthread_rwlock_t *rwlock))
01076 {
01077         <span class="keywordtype">int</span> hs, cnt;
01078         <span class="keywordtype">char</span> name[7];
01079         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01080         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK_IF, &amp;arg).i[LOW] &lt; 0) {
01081                 <span class="keywordflow">return</span> EBUSY;
01082         } <span class="keywordflow">else</span> {
01083                 rtai_lxrt(BIDX, SIZARG, RWL_UNLOCK, &amp;arg);
01084                 <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK_IF, &amp;arg).i[LOW] &lt; 0) {
01085                         <span class="keywordflow">return</span> EBUSY;
01086                 }
01087                 rtai_lxrt(BIDX, SIZARG, RWL_UNLOCK, &amp;arg);
01088         }
01089         cnt = ((<span class="keywordtype">int</span> *)rwlock)[1];
01090         <span class="keywordflow">if</span> (!cnt || (cnt &amp;&amp; atomic_dec_and_test((atomic_t *)&amp;((<span class="keywordtype">int</span> *)rwlock)[1]))) {
01091                 hs = MAKE_SOFT();
01092                 <a class="code" href="rtai__nam2num_8h.html#a1">num2nam</a>(<a class="code" href="group__lxrt.html#a54">rt_get_name</a>(((<span class="keywordtype">void</span> **)rwlock)[0]), name);
01093                 rtai_lxrt(BIDX, SIZARG, RWL_DELETE, &amp;arg);
01094                 <span class="keywordflow">if</span> (cnt) {
01095                         unlink(name);
01096                         free((<span class="keywordtype">void</span> *)rwlock);
01097                 }
01098                 MAKE_HARD(hs);
01099         }
01100         <span class="keywordflow">return</span> 0;
01101 }
01102 
01103 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_destroy_rt,(pthread_rwlock_t *rwlock))
01104 {
01105         <span class="keywordflow">return</span> pthread_rwlock_close_rt(rwlock);
01106 }
01107 
01108 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_rdlock_rt,(pthread_rwlock_t *rwlock))
01109 {
01110         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01111         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK, &amp;arg).i[LOW];
01112 }
01113 
01114 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_tryrdlock_rt,(pthread_rwlock_t *rwlock))
01115 {
01116         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01117         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK_IF, &amp;arg).i[LOW];
01118 }
01119 
01120 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_timedrdlock_rt,(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime))
01121 {
01122         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; RTIME time; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0], timespec2count(abstime) };
01123         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK_UNTIL, &amp;arg).i[LOW];
01124 }
01125 
01126 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_wrlock_rt,(pthread_rwlock_t *rwlock))
01127 {
01128         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01129         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK, &amp;arg).i[LOW];
01130 }
01131 
01132 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_trywrlock_rt,(pthread_rwlock_t *rwlock))
01133 {
01134         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01135         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK_IF, &amp;arg).i[LOW];
01136 }
01137 
01138 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_timedwrlock_rt,(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime))
01139 {
01140         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; RTIME time; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0], timespec2count(abstime) };
01141         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK_UNTIL, &amp;arg).i[LOW];
01142 }
01143 
01144 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_unlock_rt,(pthread_rwlock_t *rwlock))
01145 {
01146         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01147         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_UNLOCK, &amp;arg).i[LOW];
01148 }
01149 
01150 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_init_rt,(pthread_spinlock_t *lock))
01151 {
01152         <span class="keywordflow">return</span> (((<span class="keywordtype">int</span> *)lock)[0] = 0);
01153 }
01154 
01155 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_destroy_rt,(pthread_spinlock_t *lock))
01156 {
01157         <span class="keywordflow">return</span> ((<span class="keywordtype">int</span> *)lock)[0] = 0;
01158 }
01159 
01160 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_lock_rt,(pthread_spinlock_t *lock))
01161 {
01162         <span class="keywordflow">while</span> (atomic_cmpxchg(&amp;lock, 0, 1));
01163         <span class="keywordflow">return</span> 0;
01164 }
01165 
01166 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_trylock_rt,(pthread_spinlock_t *lock))
01167 {
01168         <span class="keywordflow">if</span> (atomic_cmpxchg(&amp;lock, 0, 1)) {
01169                 <span class="keywordflow">return</span> EAGAIN;
01170         }
01171         <span class="keywordflow">return</span> 0;
01172 }
01173 
01174 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_unlock_rt,(pthread_spinlock_t *lock))
01175 {
01176         <span class="keywordflow">return</span> ((<span class="keywordtype">int</span> *)lock)[0] = 0;
01177 }
01178 
01179 RTAI_PROTO(<span class="keywordtype">void</span>, clock_gettime_rt,(<span class="keywordtype">int</span> clockid, <span class="keyword">struct</span> timespec *current_time))
01180 {
01181         count2timespec(<a class="code" href="group__lxrt.html#a19">rt_get_time</a>(), current_time);
01182 }
01183 
01184 RTAI_PROTO(<span class="keywordtype">int</span>, nanosleep_rt,(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *rqtp, <span class="keyword">struct</span> timespec *rmtp))
01185 {
01186         RTIME expire;
01187         <span class="keywordflow">if</span> (rqtp-&gt;tv_nsec &gt;= 1000000000L || rqtp-&gt;tv_nsec &lt; 0 || rqtp-&gt;tv_sec &lt; 0) {
01188                 <span class="keywordflow">return</span> -EINVAL;
01189         }
01190         <a class="code" href="common_8c.html#a25">rt_sleep_until</a>(expire = <a class="code" href="group__lxrt.html#a19">rt_get_time</a>() + timespec2count(rqtp));
01191         <span class="keywordflow">if</span> ((expire -= <a class="code" href="group__lxrt.html#a19">rt_get_time</a>()) &gt; 0) {
01192                 <span class="keywordflow">if</span> (rmtp) {
01193                         count2timespec(expire, rmtp);
01194                 }
01195                 <span class="keywordflow">return</span> -EINTR;
01196         }
01197         <span class="keywordflow">return</span> 0;
01198 }
01199 
01200 <span class="preprocessor">#ifdef __cplusplus</span>
01201 <span class="preprocessor"></span>}
01202 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
01203 
01204 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ */</span>
01205 
01206 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_POSIX_H_ */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Jan 11 16:25:17 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
