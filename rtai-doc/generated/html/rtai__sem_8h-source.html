<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_sem.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_sem.h</h1><a href="rtai__sem_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00024 <span class="preprocessor">#ifndef _RTAI_SEM_H</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_SEM_H</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00028 
00029 <span class="preprocessor">#define RT_SEM_MAGIC 0xaabcdeff</span>
00030 <span class="preprocessor"></span>
00031 <span class="preprocessor">#define SEM_TIMOUT (0xFffe)</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#define SEM_ERR (0xFfff)</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#if defined(__KERNEL__) &amp;&amp; !defined(__cplusplus)</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00038 
00039 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore {
00040     <span class="keyword">struct </span>rt_queue queue; <span class="comment">/* &lt;= Must be first in struct. */</span>
00041     <span class="keywordtype">int</span> magic;
00042     <span class="keywordtype">int</span> type;
00043     <span class="keywordtype">int</span> count;
00044     <span class="keyword">struct </span>rt_task_struct *owndby;
00045     <span class="keywordtype">int</span> qtype;
00046 } SEM;
00047 
00048 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00049 
00050 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore {
00051     <span class="keywordtype">int</span> opaque;
00052 } SEM;
00053 
00054 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ &amp;&amp; !__cplusplus */</span>
00055 
00056 <span class="keyword">typedef</span> SEM CND;
00057 
00058 <span class="preprocessor">#ifdef __KERNEL__</span>
00059 <span class="preprocessor"></span>
00060 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00061 
00062 <span class="preprocessor">#ifdef CONFIG_RTAI_SEM_BUILTIN</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#define SEM_INIT_MODULE     sem_init_module</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#define SEM_CLEANUP_MODULE  sem_cleanup_module</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#else  </span><span class="comment">/* !CONFIG_RTAI_SEM_BUILTIN */</span>
00066 <span class="preprocessor">#define SEM_INIT_MODULE     init_module</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define SEM_CLEANUP_MODULE  cleanup_module</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_SEM_BUILTIN */</span>
00069 
00070 <span class="keyword">typedef</span> SEM psem_t;
00071 
00072 <span class="keyword">typedef</span> SEM pmutex_t;
00073 
00074 <span class="preprocessor">#ifdef __cplusplus</span>
00075 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00076 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00077 
00078 <span class="keywordtype">int</span> SEM_INIT_MODULE(<span class="keywordtype">void</span>);
00079 
00080 <span class="keywordtype">void</span> SEM_CLEANUP_MODULE(<span class="keywordtype">void</span>);
00081 
00082 <span class="keywordtype">void</span> <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(SEM *sem,
00083                        <span class="keywordtype">int</span> value,
00084                        <span class="keywordtype">int</span> type);
00085 
00086 SEM *rt_typed_named_sem_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name,
00087                              <span class="keywordtype">int</span> value,
00088                              <span class="keywordtype">int</span> type);
00089 
00090 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a338">rt_sem_init</a>(SEM *sem,
00091                  <span class="keywordtype">int</span> value);
00092 
00093 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(SEM *sem);
00094 
00095 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(SEM *sem);
00096 
00097 <span class="keywordtype">int</span> rt_sem_broadcast(SEM *sem);
00098 
00099 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(SEM *sem);
00100 
00101 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(SEM *sem);
00102 
00103 <span class="keywordtype">int</span> rt_cntsem_wait_if_and_lock(SEM *sem);
00104 
00105 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(SEM *sem,
00106                       RTIME time);
00107 
00108 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a11">rt_sem_wait_timed</a>(SEM *sem,
00109                       RTIME delay);
00110 
00111 <span class="keywordtype">int</span> rt_sem_wait_barrier(SEM *sem);
00112 
00113 <span class="keywordtype">int</span> rt_sem_count(SEM *sem);
00114 
00115 <span class="keywordtype">int</span> rt_cond_signal(CND *cnd);
00116 
00117 <span class="keywordtype">int</span> rt_cond_wait(CND *cnd,
00118                  SEM *mtx);
00119 
00120 <span class="keywordtype">int</span> rt_cond_wait_until(CND *cnd,
00121                        SEM *mtx,
00122                        RTIME time);
00123 
00124 <span class="keywordtype">int</span> rt_cond_wait_timed(CND *cnd,
00125                        SEM *mtx,
00126                        RTIME delay);
00127 
00128 <span class="preprocessor">#define rt_named_sem_init(sem_name, value)  rt_typed_named_sem_init(sem_name, value, CNT_SEM)</span>
00129 <span class="preprocessor"></span>
00130 <span class="keywordtype">int</span> rt_named_sem_delete(SEM *sem);
00131 
00132 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_init(psem_t *sem, <span class="keywordtype">int</span> pshared, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
00133 {
00134         <span class="keywordflow">if</span> (value &lt; SEM_TIMOUT) {
00135                 <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(sem, value, pshared | PRIO_Q);
00136                 <span class="keywordflow">return</span> 0;
00137         }
00138         <span class="keywordflow">return</span> -EINVAL;
00139 }
00140 
00141 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_destroy(psem_t *sem)
00142 {
00143         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt;= 0) {
00144                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00145                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(sem);
00146         }
00147         <span class="keywordflow">return</span> -EBUSY;
00148 }
00149 
00150 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_wait(psem_t *sem) {
00151     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(sem) &lt; SEM_TIMOUT ? 0 : -1;
00152 }
00153 
00154 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_timedwait(psem_t *sem, <span class="keyword">struct</span> timespec *abstime) {
00155     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00156 }
00157 
00158 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_trywait(psem_t *sem) {
00159     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt; 0 ? 0 : -EAGAIN;
00160 }
00161 
00162 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_post(psem_t *sem) {
00163     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(sem) &lt; SEM_TIMOUT ? 0 : -ERANGE;
00164 }
00165 
00166 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_getvalue(psem_t *sem, <span class="keywordtype">int</span> *sval)
00167 {
00168         <span class="keywordflow">if</span> ((*sval = <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem)) &gt; 0) {
00169                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00170         }
00171         <span class="keywordflow">return</span> 0;
00172 }
00173 
00174 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_init(pmutex_t *mutex, <span class="keywordtype">void</span> *mutexattr)
00175 {
00176         <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(mutex, 1, RES_SEM);
00177         <span class="keywordflow">return</span> 0;
00178 }
00179 
00180 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_destroy(pmutex_t *mutex)
00181 {
00182         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0) {
00183                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(mutex);
00184                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(mutex);
00185         }
00186         <span class="keywordflow">return</span> -EBUSY;
00187 }
00188 
00189 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_lock(pmutex_t *mutex) {
00190     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(mutex) &lt; SEM_TIMOUT ? 0 : -EINVAL;
00191 }
00192 
00193 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_trylock(pmutex_t *mutex) {
00194     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0 ? 0 : -EBUSY;
00195 }
00196 
00197 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_timedlock(pmutex_t *sem, <span class="keyword">struct</span> timespec *abstime) {
00198     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00199 }
00200 
00201 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_unlock(pmutex_t *mutex) {
00202     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(mutex) &lt; SEM_TIMOUT ? 0 : -EINVAL;
00203 }
00204 
00205 <span class="preprocessor">#define rt_mutex_init(mtx)             rt_typed_sem_init(mtx, 1, RES_SEM)</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_delete(mtx)           rt_sem_delete(mtx)</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_destroy(mtx)          rt_sem_delete(mtx)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_trylock(mtx)          rt_sem_wait_if(mtx)</span>
00209 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_lock(mtx)             rt_sem_wait(mtx)</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_timedlock(mtx, time)  rt_sem_wait_until(mtx, time)</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_unlock(mtx)           rt_sem_signal(mtx)</span>
00212 <span class="preprocessor"></span>
00213 <span class="preprocessor">#define rt_cond_init(cnd)                  rt_typed_sem_init(cnd, 0, BIN_SEM | PRIO_Q)</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_delete(cnd)                rt_sem_delete(cnd)</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_destroy(cnd)               rt_sem_delete(cnd)</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_broadcast(cnd)             rt_sem_broadcast(cnd)</span>
00217 <span class="preprocessor"></span>
00218 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_cond_timedwait(CND *cnd, SEM *mtx, RTIME time) {
00219     <span class="keywordflow">return</span> rt_cond_wait_until(cnd, mtx, time) &lt; SEM_TIMOUT ? 0 : -1;
00220 }
00221 
00222 <span class="preprocessor">#ifdef __cplusplus</span>
00223 <span class="preprocessor"></span>}
00224 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00225 
00226 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00227 
00228 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00229 
00230 <span class="preprocessor">#ifdef __cplusplus</span>
00231 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00232 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00233 
00234 RTAI_PROTO(SEM *, rt_typed_sem_init,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00235 {
00236         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { name, value, type };
00237         <span class="keywordflow">return</span> (SEM *)rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).v[LOW];
00238 }
00239 
<a name="l00257"></a><a class="code" href="group__lxrt.html#a338">00257</a> <span class="preprocessor">#define rt_sem_init(name, value) rt_typed_sem_init(name, value, CNT_SEM)</span>
00258 <span class="preprocessor"></span>
00259 <span class="preprocessor">#define rt_named_sem_init(sem_name, value) \</span>
00260 <span class="preprocessor">        rt_typed_named_sem_init(sem_name, value, CNT_SEM)</span>
00261 <span class="preprocessor"></span>
<a name="l00262"></a><a class="code" href="group__sem.html#a4">00262</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_delete,(SEM *sem))
00263 {
00264         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00265         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_SEM_DELETE, &amp;arg).i[LOW];
00266 }
00267 
00268 RTAI_PROTO(SEM *, rt_typed_named_sem_init,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00269 {
00270         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *name; <span class="keywordtype">int</span> value, type; } arg = { name, value, type };
00271         <span class="keywordflow">return</span> (SEM *)rtai_lxrt(BIDX, SIZARG, NAMED_SEM_INIT, &amp;arg).v[LOW];
00272 }
00273 
00274 RTAI_PROTO(<span class="keywordtype">int</span>, rt_named_sem_delete,(SEM *sem))
00275 {
00276         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00277         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NAMED_SEM_DELETE, &amp;arg).i[LOW];
00278 }
00279 
<a name="l00280"></a><a class="code" href="group__sem.html#a6">00280</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_signal,(SEM *sem))
00281 {
00282         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00283         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_SIGNAL, &amp;arg).i[LOW];
00284 }
00285 
00286 RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_broadcast,(SEM *sem))
00287 {
00288         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00289         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_BROADCAST, &amp;arg).i[LOW];
00290 }
00291 
<a name="l00292"></a><a class="code" href="group__sem.html#a8">00292</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait,(SEM *sem))
00293 {
00294         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00295         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT, &amp;arg).i[LOW];
00296 }
00297 
<a name="l00298"></a><a class="code" href="group__sem.html#a9">00298</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_if,(SEM *sem))
00299 {
00300         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00301         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW];
00302 }
00303 
<a name="l00304"></a><a class="code" href="group__sem.html#a10">00304</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_until,(SEM *sem, RTIME time))
00305 {
00306         <span class="keyword">struct </span>{ SEM *sem; RTIME time; } arg = { sem, time };
00307         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_UNTIL, &amp;arg).i[LOW];
00308 }
00309 
<a name="l00310"></a><a class="code" href="group__sem.html#a11">00310</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_timed,(SEM *sem, RTIME delay))
00311 {
00312         <span class="keyword">struct </span>{ SEM *sem; RTIME delay; } arg = { sem, delay };
00313         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_TIMED, &amp;arg).i[LOW];
00314 }
00315 
00316 RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_barrier,(SEM *sem))
00317 {
00318         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00319         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_BARRIER, &amp;arg).i[LOW];
00320 }
00321 
00322 RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_count,(SEM *sem))
00323 {
00324         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00325         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_COUNT, &amp;arg).i[LOW];
00326 }
00327 
00328 <span class="preprocessor">#define rt_cond_init(cnd)                  rt_typed_sem_init(cnd, 0, BIN_SEM)</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_delete(cnd)                rt_sem_delete(cnd)</span>
00330 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_destroy(cnd)               rt_sem_delete(cnd)</span>
00331 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_broadcast(cnd)             rt_sem_broadcast(cnd)</span>
00332 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_timedwait(cnd, mtx, time)  rt_cond_wait_until(cnd, mtx, time)</span>
00333 <span class="preprocessor"></span>
00334 RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_signal,(CND *cnd))
00335 {
00336         <span class="keyword">struct </span>{ CND *cnd; } arg = { cnd };
00337         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_SIGNAL, &amp;arg).i[LOW];
00338 }
00339 
00340 RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait,(CND *cnd, SEM  *mutex))
00341 {
00342         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; } arg = { cnd, mutex };
00343         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT, &amp;arg).i[LOW];
00344 }
00345 
00346 RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait_until,(CND *cnd, SEM *mutex, RTIME time))
00347 {
00348         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; RTIME time; } arg = { cnd, mutex, time };
00349         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_UNTIL, &amp;arg).i[LOW];
00350 }
00351 
00352 RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait_timed,(CND *cnd, SEM *mutex, RTIME delay))
00353 {
00354         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; RTIME delay; } arg = { cnd, mutex, delay };
00355         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_TIMED, &amp;arg).i[LOW];
00356 }
00357 
00358 <span class="preprocessor">#ifdef __cplusplus</span>
00359 <span class="preprocessor"></span>}
00360 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00361 
00362 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00363 
00364 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_SEM_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Jan 11 16:25:17 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
