<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_netrpc.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_netrpc.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00006 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00007 <span class="comment"> * License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> * GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="preprocessor">#ifndef _RTAI_NETRPC_H</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_NETRPC_H</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include &lt;rtai_config.h&gt;</span>
00023 
00024 <span class="preprocessor">#ifdef __CONFIG_RTAI_LXRT_SUPPORT</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include &lt;<a class="code" href="rtai__registry_8h.html">rtai_registry.h</a>&gt;</span>
00027 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00029 <span class="preprocessor">#include &lt;<a class="code" href="rtai__mbx_8h.html">rtai_mbx.h</a>&gt;</span>
00030 <span class="preprocessor">#include &lt;rtai_msg.h&gt;</span>
00031 
00032 <span class="preprocessor">#define MAX_STUBS     16  // _M_U_S_T___B_E___P_O_W_E_R___O_F___2_</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define MAX_SOCKS     16</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define MAX_MSG_SIZE  1500</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#define NET_RPC_EXT  0</span>
00037 <span class="preprocessor"></span>
00038 <span class="comment">// for writes</span>
00039 <span class="preprocessor">#define UW1(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9))) &lt;&lt; 32) | 0x300000001LL)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define UW2(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23))) &lt;&lt; 32) | 0x300000001LL)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ1LL      (0x4000000300000001LL)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ2LL      (0x8000000300000001LL)</span>
00043 <span class="preprocessor"></span>
00044 <span class="comment">// for reads</span>
00045 <span class="preprocessor">#define UR1(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9) | 0x300000001LL)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define UR2(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23) | 0x300000001LL)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define URSZ1LL      (0x340000001LL)</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define URSZ2LL      (0x380000001LL)</span>
00049 <span class="preprocessor"></span>
00050 <span class="preprocessor">#define SIZARG sizeof(arg)</span>
00051 <span class="preprocessor"></span>
00052 <span class="preprocessor">#define PACKPORT(port, ext, fun, timed) (((port) &lt;&lt; 18) | ((timed) &lt;&lt; 13) | ((ext) &lt;&lt; 8) | (fun))</span>
00053 <span class="preprocessor"></span>
00054 <span class="preprocessor">#define PORT(i)   ((i) &gt;&gt; 18)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define FUN(i)    ((i) &amp; 0xFF)</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define EXT(i)    (((i) &gt;&gt; 8) &amp; 0x1F)</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#define TIMED(i)  (((i) &gt;&gt; 13) &amp; 0x1F)</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">/* </span>
00060 <span class="comment"> * SYNC_NET_RPC is hard wired here, no need to have it elsewhere. It must </span>
00061 <span class="comment"> * have all the bits allowed to the "fun" field, in PACKPORT above, set.</span>
00062 <span class="comment"> */</span>
00063 <span class="preprocessor">#define SYNC_NET_RPC  0xFF  // hard wired here, no need to have it elsewhere</span>
00064 <span class="preprocessor"></span>
00065 <span class="preprocessor">#define PRT_REQ  1</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define PRT_SRV  2</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define PRT_RTR  3</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define PRT_RCV  4</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#define RPC_REQ  5</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#define RPC_SRV  6</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#define RPC_RTR  7</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#define RPC_RCV  8</span>
00073 <span class="preprocessor"></span>
00074 <span class="preprocessor">#define OWNER(node, task) \</span>
00075 <span class="preprocessor">        ((((unsigned long long)(node)) &lt;&lt; 32) | (unsigned long)(task))</span>
00076 <span class="preprocessor"></span>
00077 <span class="preprocessor">#ifdef __KERNEL__</span>
00078 <span class="preprocessor"></span>
00079 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00080 
00081 <span class="preprocessor">#ifdef CONFIG_RTAI_NETRPC_BUILTIN</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define NETRPC_INIT_MODULE     netrpc_init_module</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define NETRPC_CLEANUP_MODULE  netrpc_cleanup_module</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#else  </span><span class="comment">/* !CONFIG_RTAI_NETRPC_BUILTIN */</span>
00085 <span class="preprocessor">#define NETRPC_INIT_MODULE     init_module</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define NETRPC_CLEANUP_MODULE  cleanup_module</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_NETRPC_BUILTIN */</span>
00088 
00089 <span class="preprocessor">#ifdef __cplusplus</span>
00090 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00091 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00092 
00093 <span class="keywordtype">int</span> netrpc_init_module(<span class="keywordtype">void</span>);
00094 
00095 <span class="keywordtype">void</span> netrpc_cleanup_module(<span class="keywordtype">void</span>);
00096 
00097 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> rt_net_rpc(<span class="keywordtype">int</span> fun_ext_timed,
00098                               <span class="keywordtype">long</span> <span class="keywordtype">long</span> type,
00099                               <span class="keywordtype">void</span> *args,
00100                               <span class="keywordtype">int</span> argsize);
00101 
00102 <span class="keywordtype">int</span> rt_send_req_rel_port(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node,
00103                          <span class="keywordtype">int</span> port,
00104                          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> id,
00105                          MBX *mbx,
00106                          <span class="keywordtype">int</span> hard);
00107 
00108 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ddn2nl(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn);
00109 
00110 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rt_set_this_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn,
00111                                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node,
00112                                <span class="keywordtype">int</span> hard);
00113 
00114 RT_TASK *rt_find_asgn_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner,
00115                            <span class="keywordtype">int</span> asgn);
00116 
00117 <span class="keywordtype">int</span> rt_rel_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner);
00118 
00119 <span class="keywordtype">int</span> rt_waiting_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node,
00120                       <span class="keywordtype">int</span> port);
00121 
00122 <span class="keywordtype">int</span> rt_get_net_rpc_ret(MBX *mbx,
00123                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *retval,
00124                        <span class="keywordtype">void</span> *msg1,
00125                        <span class="keywordtype">int</span> *msglen1,
00126                        <span class="keywordtype">void</span> *msg2,
00127                        <span class="keywordtype">int</span> *msglen2,
00128                        RTIME timeout,
00129                        <span class="keywordtype">int</span> type);
00130 
00131 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_sync_net_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00132 {
00133         <span class="keywordflow">if</span> (node) {
00134                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00135                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(abs(port), NET_RPC_EXT, SYNC_NET_RPC, 0), 0LL, &amp;arg, SIZARG);
00136         }
00137         <span class="keywordflow">return</span> 1;
00138 } 
00139 
00140 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *RT_get_adr(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sname)
00141 {
00142         <span class="keywordflow">if</span> (node) {
00143                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname) };
00144                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_ADR, 0), 0LL, &amp;arg, SIZARG);
00145         }
00146         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#a55">rt_get_adr</a>(<a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname));
00147 } 
00148 
00149 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_named_task_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name, <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>), <span class="keywordtype">int</span> data, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> prio, <span class="keywordtype">int</span> uses_fpu, <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>))
00150 {
00151         <span class="keywordflow">if</span> (node) {
00152                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name; void (*thread)(<span class="keywordtype">int</span>); <span class="keywordtype">int</span> data; <span class="keywordtype">int</span> stack_size; <span class="keywordtype">int</span> prio; <span class="keywordtype">int</span> uses_fpu; void(*signal)(<span class="keywordtype">void</span>); <span class="keywordtype">int</span> namelen; } arg = { task_name, thread, data, stack_size, prio, uses_fpu, signal, strlen(task_name) };
00153                 <span class="keywordflow">return</span> (RT_TASK *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_TASK_INIT, 0), UR1(1, 8), &amp;arg, SIZARG);
00154         }
00155         <span class="keywordflow">return</span> rt_named_task_init(task_name, thread, data, stack_size, prio, uses_fpu, signal);
00156 }
00157 
00158 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_named_task_init_cpuid(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name, <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>), <span class="keywordtype">int</span> data, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> prio, <span class="keywordtype">int</span> uses_fpu, <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>), <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_on_cpu)
00159 {
00160         <span class="keywordflow">if</span> (node) {
00161                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name; void (*thread)(<span class="keywordtype">int</span>); <span class="keywordtype">int</span> data; <span class="keywordtype">int</span> stack_size; <span class="keywordtype">int</span> prio; <span class="keywordtype">int</span> uses_fpu; void(*signal)(<span class="keywordtype">void</span>); <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_on_cpu; <span class="keywordtype">int</span> namelen; } arg = { task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu, strlen(task_name) };
00162                 <span class="keywordflow">return</span> (RT_TASK *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_TASK_INIT_CPUID, 0), UR1(1, 9), &amp;arg, SIZARG);
00163         }
00164         <span class="keywordflow">return</span> rt_named_task_init_cpuid(task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu);
00165 }
00166 
00167 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_task_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00168 {
00169         <span class="keywordflow">if</span> (node) {
00170                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00171                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_TASK_DELETE, 0), 0LL, &amp;arg, SIZARG);
00172         }
00173         <span class="keywordflow">return</span> rt_named_task_delete(task);
00174 }
00175 
00176 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00177 {
00178         <span class="keywordflow">if</span> (node) {
00179                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00180                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_TIME_NS, 0), 0LL, &amp;arg, SIZARG);
00181         }
00182         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#a30">rt_get_time_ns</a>();
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns_cpuid(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> cpuid)
00186 {
00187         <span class="keywordflow">if</span> (node) {
00188                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00189                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_TIME_NS_CPUID, 0), 0LL, &amp;arg, SIZARG);
00190         }
00191         <span class="keywordflow">return</span> <a class="code" href="sched__up_8c.html#a97">rt_get_time_ns_cpuid</a>(cpuid);
00192 }
00193 
00194 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_cpu_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00195 {
00196         <span class="keywordflow">if</span> (node) {
00197                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00198                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_CPU_TIME_NS, 0), 0LL, &amp;arg, SIZARG);
00199         }
00200         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#a31">rt_get_cpu_time_ns</a>();
00201 }
00202 
00203 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_task_suspend(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00204 {
00205         <span class="keywordflow">if</span> (node) {
00206                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00207                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SUSPEND, 0), 0LL, &amp;arg, SIZARG);
00208         }
00209         <span class="keywordflow">return</span> <a class="code" href="common_8c.html#a9">rt_task_suspend</a>(task);
00210 }
00211 
00212 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_task_resume(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00213 {
00214         <span class="keywordflow">if</span> (node) {
00215                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00216                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RESUME, 0), 0LL, &amp;arg, SIZARG);
00217         }
00218         <span class="keywordflow">return</span> <a class="code" href="common_8c.html#a10">rt_task_resume</a>(task);
00219 }
00220 
00221 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME delay)
00222 {
00223         <span class="keywordflow">if</span> (node) {
00224                 <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00225                 rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SLEEP, 1), 0LL, &amp;arg, SIZARG);
00226                 <span class="keywordflow">return</span>;
00227         }
00228         <a class="code" href="common_8c.html#a24">rt_sleep</a>(<a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00229 } 
00230 
00231 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME time)
00232 {
00233         <span class="keywordflow">if</span> (node) {
00234                 <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00235                 rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SLEEP_UNTIL, 1), 0LL, &amp;arg, SIZARG);
00236                 <span class="keywordflow">return</span>;
00237         }
00238         <a class="code" href="common_8c.html#a25">rt_sleep_until</a>(<a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00239 } 
00240 
00241 <span class="preprocessor">#if CONFIG_RTAI_SEM</span>
00242 <span class="preprocessor"></span>
00243 <span class="keyword">static</span> <span class="keyword">inline</span> SEM *RT_typed_named_sem_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type)
00244 {
00245         <span class="keywordflow">if</span> (node) {
00246                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name; <span class="keywordtype">int</span> value; <span class="keywordtype">int</span> type; <span class="keywordtype">int</span> namelen; } arg = { sem_name, value, type, strlen(sem_name) };
00247                 <span class="keywordflow">return</span> (SEM *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_SEM_INIT, 0), UR1(1, 4), &amp;arg, SIZARG);
00248         }
00249         <span class="keywordflow">return</span> rt_typed_named_sem_init(sem_name, value, type);
00250 }
00251 
00252 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_sem_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00253 {
00254         <span class="keywordflow">if</span> (node) {
00255                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00256                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_SEM_DELETE, 0), 0LL, &amp;arg, SIZARG);
00257         }
00258         <span class="keywordflow">return</span> rt_named_sem_delete(sem);
00259 }
00260 
00261 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_signal(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00262 {
00263         <span class="keywordflow">if</span> (node) {
00264                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00265                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_SIGNAL, 0), 0LL, &amp;arg, SIZARG);
00266         }
00267         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00268 } 
00269 
00270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_broadcast(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00271 {
00272         <span class="keywordflow">if</span> (node) {
00273                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00274                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_BROADCAST, 0), 0LL, &amp;arg, SIZARG);
00275         }
00276         <span class="keywordflow">return</span> rt_sem_broadcast(sem);
00277 } 
00278 
00279 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00280 {
00281         <span class="keywordflow">if</span> (node) {
00282                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00283                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT, 0), 0LL, &amp;arg, SIZARG);
00284         }
00285         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(sem);
00286 } 
00287 
00288 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00289 {
00290         <span class="keywordflow">if</span> (node) {
00291                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00292                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT_IF, 0), 0LL, &amp;arg, SIZARG);
00293         }
00294         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem);
00295 } 
00296 
00297 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME time)
00298 {
00299         <span class="keywordflow">if</span> (node) {
00300                 <span class="keyword">struct </span>{ SEM *sem; RTIME time; } arg = { sem, time };
00301                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT_UNTIL, 2), 0LL, &amp;arg, SIZARG);
00302         }
00303         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00304 } 
00305 
00306 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME delay)
00307 {
00308         <span class="keywordflow">if</span> (node) {
00309                 <span class="keyword">struct </span>{ SEM *sem; RTIME delay; } arg = { sem, delay };
00310                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT_TIMED, 2), 0LL, &amp;arg, SIZARG);
00311         }
00312         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a11">rt_sem_wait_timed</a>(sem, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00313 } 
00314 
00315 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_SEM */</span>
00316 
00317 <span class="preprocessor">#if CONFIG_RTAI_MSG</span>
00318 <span class="preprocessor"></span>
00319 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00320 {
00321         <span class="keywordflow">if</span> (node) {
00322                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00323                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDMSG, 0), 0LL, &amp;arg, SIZARG);
00324         }
00325         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a0">rt_send</a>(task, msg);
00326 }
00327 
00328 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00329 {
00330         <span class="keywordflow">if</span> (node) {
00331                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00332                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEND_IF, 0), 0LL, &amp;arg, SIZARG);
00333         }
00334         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a1">rt_send_if</a>(task, msg);
00335 }
00336 
00337 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME time)
00338 {
00339         <span class="keywordflow">if</span> (node) {
00340                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME time; } arg = { task, msg, time };
00341                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEND_UNTIL, 3), 0LL, &amp;arg, SIZARG);
00342         }
00343         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a2">rt_send_until</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00344 }
00345 
00346 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME delay)
00347 {
00348         <span class="keywordflow">if</span> (node) {
00349                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME delay; } arg = { task, msg, delay };
00350                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEND_TIMED, 3), 0LL, &amp;arg, SIZARG);
00351         }
00352         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a3">rt_send_timed</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00353 }
00354 
00355 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00356 {
00357         <span class="keywordflow">if</span> (!task || !node) {
00358                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a4">rt_receive</a>(task, msg);
00359         }
00360         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a4">rt_receive</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00361 }
00362 
00363 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00364 {
00365         <span class="keywordflow">if</span> (!task || !node) {
00366                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a5">rt_receive_if</a>(task, msg);
00367         }
00368         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a5">rt_receive_if</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00369 }
00370 
00371 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME time)
00372 {
00373         <span class="keywordflow">if</span> (!task || !node) {
00374                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a6">rt_receive_until</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00375         }
00376         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a6">rt_receive_until</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time)) ? task : 0;
00377 }
00378 
00379 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME delay)
00380 {
00381         <span class="keywordflow">if</span> (!task || !node) {
00382                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a7">rt_receive_timed</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00383         }
00384         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a7">rt_receive_timed</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay)) ? task : 0;
00385 }
00386 
00387 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
00388 {
00389         <span class="keywordflow">if</span> (node) {
00390                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg, ret };
00391                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCMSG, 0), UW1(3, 0), &amp;arg, SIZARG);
00392         }
00393         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a0">rt_rpc</a>(task, msg, ret);
00394 }
00395 
00396 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
00397 {
00398         <span class="keywordflow">if</span> (node) {
00399                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg };
00400                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPC_IF, 0), UW1(3, 0), &amp;arg, SIZARG);
00401         }
00402         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a1">rt_rpc_if</a>(task, msg, ret);
00403 }
00404 
00405 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME time)
00406 {
00407         <span class="keywordflow">if</span> (node) {
00408                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME time; } arg = { task, msg, ret, time };
00409                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPC_UNTIL, 4), UW1(3, 0), &amp;arg, SIZARG);
00410         }
00411         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a2">rt_rpc_until</a>(task, msg, ret, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00412 }
00413 
00414 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME delay)
00415 {
00416         <span class="keywordflow">if</span> (node) {
00417                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME delay; } arg = { task, msg, ret, delay };
00418                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPC_TIMED, 4), UW1(3, 0), &amp;arg, SIZARG);
00419         }
00420         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a3">rt_rpc_timed</a>(task, msg, ret, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00421 }
00422 
00423 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_isrpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00424 {
00425         <span class="keywordflow">if</span> (node) {
00426                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00427                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, ISRPC, 0), 0LL, &amp;arg, SIZARG);
00428         }
00429         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a4">rt_isrpc</a>(task);
00430 }
00431 
00432 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result)
00433 {
00434         <span class="keywordflow">if</span> (!task || !node) {
00435                 <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a5">rt_return</a>(task, result);
00436         }
00437         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a5">rt_return</a>(rt_find_asgn_stub(OWNER(node, task), 1), result) ? task : 0;
00438 }
00439 
00440 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00441 {
00442         <span class="keywordflow">if</span> (!task || !node) {
00443                 <span class="keywordflow">return</span> rt_evdrp(task, msg);
00444         }
00445         <span class="keywordflow">return</span> rt_evdrp(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00446 }
00447 
00448 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
00449 {
00450         <span class="keywordflow">if</span> (node) {
00451                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00452                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00453         }
00454         <span class="keywordflow">return</span> rt_rpcx(task, smsg, rmsg, ssize, rsize);
00455 }
00456 
00457 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
00458 {
00459         <span class="keywordflow">if</span> (node) {
00460                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00461                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX_IF, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00462         }
00463         <span class="keywordflow">return</span> rt_rpcx_if(task, smsg, rmsg, ssize, rsize);
00464 }
00465 
00466 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME time)
00467 {
00468         <span class="keywordflow">if</span> (node) {
00469                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME time; } arg = { task, smsg, rmsg, ssize, rsize, time };
00470                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX_UNTIL, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00471         }
00472         <span class="keywordflow">return</span> rt_rpcx_until(task, smsg, rmsg, ssize, rsize, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00473 }
00474 
00475 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME delay)
00476 {
00477         <span class="keywordflow">if</span> (node) {
00478                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME delay; } arg = { task, smsg, rmsg, ssize, rsize, delay };
00479                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX_TIMED, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00480         }
00481         <span class="keywordflow">return</span> rt_rpcx_timed(task, smsg, rmsg, ssize, rsize, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00482 }
00483 
00484 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
00485 {
00486         <span class="keywordflow">if</span> (node) {
00487                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00488                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX, 0), UR1(2, 3), &amp;arg, SIZARG);
00489         }
00490         <span class="keywordflow">return</span> rt_sendx(task, msg, size);
00491 }
00492 
00493 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
00494 {
00495         <span class="keywordflow">if</span> (node) {
00496                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00497                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX_IF, 0), UR1(2, 3), &amp;arg, SIZARG);
00498         }
00499         <span class="keywordflow">return</span> rt_sendx_if(task, msg, size);
00500 }
00501 
00502 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME time)
00503 {
00504         <span class="keywordflow">if</span> (node) {
00505                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME time; } arg = { task, msg, size, time };
00506                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG);
00507         }
00508         <span class="keywordflow">return</span> rt_sendx_until(task, msg, size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00509 }
00510 
00511 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME delay)
00512 {
00513         <span class="keywordflow">if</span> (node) {
00514                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME delay; } arg = { task, msg, size, delay };
00515                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG);
00516         }
00517         <span class="keywordflow">return</span> rt_sendx_timed(task, msg, size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00518 }
00519 
00520 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_returnx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
00521 {
00522         <span class="keywordflow">if</span> (!task || !node) {
00523                 <span class="keywordflow">return</span> rt_returnx(task, msg, size);
00524         }
00525         <span class="keywordflow">return</span> rt_returnx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size) ? task : 0;
00526 }
00527 
00528 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrpx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
00529 {
00530         <span class="keywordflow">if</span> (!task || !node) {
00531                 <span class="keywordflow">return</span> rt_evdrpx(task, msg, size, len);
00532         }
00533         <span class="keywordflow">return</span> rt_evdrpx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
00534 }
00535 
00536 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
00537 {
00538         <span class="keywordflow">if</span> (!task || !node) {
00539                 <span class="keywordflow">return</span> rt_receivex(task, msg, size, len);
00540         }
00541         <span class="keywordflow">return</span> rt_receivex(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
00542 }
00543 
00544 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
00545 {
00546         <span class="keywordflow">if</span> (!task || !node) {
00547                 <span class="keywordflow">return</span> rt_receivex_if(task, msg, size, len);
00548         }
00549         <span class="keywordflow">return</span> rt_receivex_if(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
00550 }
00551 
00552 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME time)
00553 {
00554         <span class="keywordflow">if</span> (!task || !node) {
00555                 <span class="keywordflow">return</span> rt_receivex_until(task, msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00556         }
00557         <span class="keywordflow">return</span> rt_receivex_until(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time)) ? task : 0;
00558 }
00559 
00560 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME delay)
00561 {
00562         <span class="keywordflow">if</span> (!task || !node) {
00563                 <span class="keywordflow">return</span> rt_receivex_timed(task, msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00564         }
00565         <span class="keywordflow">return</span> rt_receivex_timed(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay)) ? task : 0;
00566 }
00567 
00568 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MSG */</span>
00569 
00570 <span class="preprocessor">#if CONFIG_RTAI_MBX</span>
00571 <span class="preprocessor"></span>
00572 <span class="keyword">static</span> <span class="keyword">inline</span> MBX *RT_typed_named_mbx_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *mbx_name, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> qtype)
00573 {
00574         <span class="keywordflow">if</span> (node) {
00575                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *mbx_name; <span class="keywordtype">int</span> size; <span class="keywordtype">int</span> qype; <span class="keywordtype">int</span> namelen; } arg = { mbx_name, size, qtype, strlen(mbx_name) };
00576                 <span class="keywordflow">return</span> (MBX *)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_MBX_INIT, 0), UR1(1, 4), &amp;arg, SIZARG);
00577         }
00578         <span class="keywordflow">return</span> rt_typed_named_mbx_init(mbx_name, size, qtype);
00579 }
00580 
00581 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_mbx_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx)
00582 {
00583         <span class="keywordflow">if</span> (node) {
00584                 <span class="keyword">struct </span>{ MBX *mbx; } arg = { mbx };
00585                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_MBX_DELETE, 0), 0LL, &amp;arg, SIZARG);
00586         }
00587         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a12">rt_mbx_delete</a>(mbx);
00588 }
00589 
00590 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00591 {
00592         <span class="keywordflow">if</span> (node) {
00593                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00594                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND, 0), UR1(2, 3), &amp;arg, SIZARG);
00595         }
00596         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a13">rt_mbx_send</a>(mbx, msg, msg_size);
00597 } 
00598 
00599 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00600 {
00601         <span class="keywordflow">if</span> (node) {
00602                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00603                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_WP, 0), UR1(2, 3), &amp;arg, SIZARG);
00604         }
00605         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a14">rt_mbx_send_wp</a>(mbx, msg, msg_size);
00606 } 
00607 
00608 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00609 {
00610         <span class="keywordflow">if</span> (node) {
00611                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00612                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_IF, 0), UR1(2, 3), &amp;arg, SIZARG);
00613         }
00614         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a15">rt_mbx_send_if</a>(mbx, msg, msg_size);
00615 } 
00616 
00617 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
00618 {
00619         <span class="keywordflow">if</span> (node) {
00620                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
00621                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG);
00622         }
00623         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a16">rt_mbx_send_until</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00624 } 
00625 
00626 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
00627 {
00628         <span class="keywordflow">if</span> (node) {
00629                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
00630                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG);
00631         }
00632         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a17">rt_mbx_send_timed</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00633 } 
00634 
00635 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00636 {
00637         <span class="keywordflow">if</span> (node) {
00638                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00639                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_EVDRP, 0), UW1(2, 3), &amp;arg, SIZARG);
00640         }
00641         <span class="keywordflow">return</span> rt_mbx_evdrp(mbx, msg, msg_size);
00642 } 
00643 
00644 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00645 {
00646         <span class="keywordflow">if</span> (node) {
00647                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00648                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE, 0), UW1(2, 3), &amp;arg, SIZARG);
00649         }
00650         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a18">rt_mbx_receive</a>(mbx, msg, msg_size);
00651 } 
00652 
00653 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00654 {
00655         <span class="keywordflow">if</span> (node) {
00656                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00657                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_WP, 0), UW1(2, 3), &amp;arg, SIZARG);
00658         }
00659         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a19">rt_mbx_receive_wp</a>(mbx, msg, msg_size);
00660 } 
00661 
00662 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00663 {
00664         <span class="keywordflow">if</span> (node) {
00665                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00666                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_IF, 0), UW1(2, 3), &amp;arg, SIZARG);
00667         }
00668         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a20">rt_mbx_receive_if</a>(mbx, msg, msg_size);
00669 } 
00670 
00671 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
00672 {
00673         <span class="keywordflow">if</span> (node) {
00674                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
00675                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_UNTIL, 4), UW1(2, 3), &amp;arg, SIZARG);
00676         }
00677         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a21">rt_mbx_receive_until</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00678 } 
00679 
00680 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
00681 {
00682         <span class="keywordflow">if</span> (node) {
00683                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
00684                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_TIMED, 4), UW1(2, 3), &amp;arg, SIZARG);
00685         }
00686         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a22">rt_mbx_receive_timed</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00687 } 
00688 
00689 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MBX */</span>
00690 
00691 <span class="preprocessor">#ifdef __cplusplus</span>
00692 <span class="preprocessor"></span>}
00693 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00694 
00695 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00696 
00697 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00698 
00699 <span class="preprocessor">#define NET_RPC_IDX  0</span>
00700 <span class="preprocessor"></span>
00701 <span class="preprocessor">#define SIZARGS sizeof(args)</span>
00702 <span class="preprocessor"></span>
00703 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_send_req_rel_port(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> id, MBX *mbx, <span class="keywordtype">int</span> hard)
00704 {
00705         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, port; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> id; MBX *mbx; <span class="keywordtype">int</span> hard; } args = { node, port, id, mbx, hard };
00706         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, SEND_REQ_REL_PORT, &amp;args).i[LOW];
00707 } 
00708 
00709 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ddn2nl(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn)
00710 {
00711         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *ddn; } args = { ddn };
00712         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, DDN2NL, &amp;args).i[LOW];
00713 } 
00714 
00715 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rt_set_this_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> hard)
00716 {
00717         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *ddn; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node; <span class="keywordtype">int</span> hard; } args = { ddn, node, hard };
00718         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, SET_THIS_NODE, &amp;args).i[LOW];
00719 } 
00720 
00721 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *rt_find_asgn_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner, <span class="keywordtype">int</span> asgn)
00722 {
00723         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner; <span class="keywordtype">int</span> asgn; } args = { owner, asgn };
00724         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, FIND_ASGN_STUB, &amp;args).v[LOW];
00725 } 
00726 
00727 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_rel_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner)
00728 {
00729         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner; } args = { owner };
00730         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, REL_STUB, &amp;args).i[LOW];
00731 } 
00732 
00733 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_waiting_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00734 {
00735         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node; <span class="keywordtype">int</span> port; } args = { node, port };
00736         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, WAITING_RETURN, &amp;args).i[LOW];
00737 } 
00738 
00739 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_sync_net_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00740 {
00741         <span class="keywordflow">if</span> (node) {
00742                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00743                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(abs(port), NET_RPC_EXT, SYNC_NET_RPC, 0), 0LL, &amp;arg, SIZARG };
00744                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00745         } 
00746         <span class="keywordflow">return</span> 1;
00747 } 
00748 
00749 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *RT_get_adr(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sname)
00750 {
00751         <span class="keywordflow">if</span> (node) {
00752                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname) };
00753                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_ADR, 0), 0LL, &amp;arg, SIZARG };
00754                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00755         } 
00756         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#a55">rt_get_adr</a>(<a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname));
00757 } 
00758 
00759 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00760 {
00761         <span class="keywordflow">if</span> (node) {
00762                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00763                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_TIME_NS, 0), 0LL, &amp;arg, SIZARG };
00764                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).rt;
00765         }
00766         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#a30">rt_get_time_ns</a>();
00767 } 
00768 
00769 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns_cpuid(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> cpuid)
00770 {
00771         <span class="keywordflow">if</span> (node) {
00772                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00773                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_TIME_NS_CPUID, 0), 0LL, &amp;arg, SIZARG };
00774                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).rt;
00775         }
00776         <span class="keywordflow">return</span> <a class="code" href="sched__up_8c.html#a97">rt_get_time_ns_cpuid</a>(cpuid);
00777 } 
00778 
00779 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_cpu_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00780 {
00781         <span class="keywordflow">if</span> (node) {
00782                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00783                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_CPU_TIME_NS, 0), 0LL, &amp;arg, SIZARG };
00784                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).rt;
00785         }
00786         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#a31">rt_get_cpu_time_ns</a>();
00787 } 
00788 
00789 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_task_suspend(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00790 {
00791         <span class="keywordflow">if</span> (node) {
00792                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00793                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SUSPEND, 0), 0LL, &amp;arg, SIZARG };
00794                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00795                 <span class="keywordflow">return</span>;
00796         }
00797         <a class="code" href="common_8c.html#a9">rt_task_suspend</a>(task);
00798 } 
00799 
00800 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_task_resume(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00801 {
00802         <span class="keywordflow">if</span> (node) {
00803                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00804                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RESUME, 0), 0LL, &amp;arg, SIZARG };
00805                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00806                 <span class="keywordflow">return</span>;
00807         }
00808         <a class="code" href="common_8c.html#a10">rt_task_resume</a>(task);
00809 } 
00810 
00811 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME delay)
00812 {
00813         <span class="keywordflow">if</span> (node) {
00814                 <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00815                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SLEEP, 1), 0LL, &amp;arg, SIZARG };
00816                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00817                 <span class="keywordflow">return</span>;
00818         }
00819         <a class="code" href="common_8c.html#a24">rt_sleep</a>(<a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00820 } 
00821 
00822 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME time)
00823 {
00824         <span class="keywordflow">if</span> (node) {
00825                 <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00826                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SLEEP_UNTIL, 1), 0LL, &amp;arg, SIZARG };
00827                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00828                 <span class="keywordflow">return</span>;
00829         }
00830         <a class="code" href="common_8c.html#a24">rt_sleep</a>(<a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00831 } 
00832 
00833 <span class="preprocessor">#if CONFIG_RTAI_SEM</span>
00834 <span class="preprocessor"></span>
00835 <span class="keyword">static</span> <span class="keyword">inline</span> SEM *RT_typed_named_sem_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type)
00836 {
00837         <span class="keywordflow">if</span> (node) {
00838                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name; <span class="keywordtype">int</span> value; <span class="keywordtype">int</span> type; <span class="keywordtype">int</span> namelen; } arg = { sem_name, value, type, strlen(sem_name) };
00839                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_SEM_INIT, 0), 0LL, &amp;arg, SIZARG };
00840                 <span class="keywordflow">return</span> (SEM *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00841         }
00842         <span class="keywordflow">return</span> rt_typed_named_sem_init(sem_name, value, type);
00843 }
00844 
00845 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_sem_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00846 {
00847         <span class="keywordflow">if</span> (node) {
00848                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00849                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_SEM_DELETE, 0), 0LL, &amp;arg, SIZARG };
00850                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00851         }
00852         <span class="keywordflow">return</span> rt_named_sem_delete(sem);
00853 }
00854 
00855 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_signal(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00856 {
00857         <span class="keywordflow">if</span> (node) {
00858                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00859                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_SIGNAL, 0), 0LL, &amp;arg, SIZARG };
00860                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00861         } 
00862         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00863 } 
00864 
00865 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_broadcast(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00866 {
00867         <span class="keywordflow">if</span> (node) {
00868                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00869                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_BROADCAST, 0), 0LL, &amp;arg, SIZARG };
00870                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00871         }
00872         <span class="keywordflow">return</span> rt_sem_broadcast(sem);
00873 } 
00874 
00875 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00876 {
00877         <span class="keywordflow">if</span> (node) {
00878                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00879                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT, 0), 0LL, &amp;arg, SIZARG };
00880                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00881         } 
00882         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(sem);
00883 } 
00884 
00885 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00886 {
00887         <span class="keywordflow">if</span> (node) {
00888                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00889                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT_IF, 0), 0LL, &amp;arg, SIZARG };
00890                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00891         }
00892         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem);
00893 } 
00894 
00895 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME time)
00896 {
00897         <span class="keywordflow">if</span> (node) {
00898                 <span class="keyword">struct </span>{ SEM *sem; RTIME time; } arg = { sem, time };
00899                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT_UNTIL, 2), 0LL, &amp;arg, SIZARG };
00900                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00901         }
00902         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00903 } 
00904 
00905 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME delay)
00906 {
00907         <span class="keywordflow">if</span> (node) {
00908                 <span class="keyword">struct </span>{ SEM *sem; RTIME delay; } arg = { sem, delay };
00909                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT_TIMED, 2), 0LL, &amp;arg, SIZARG };
00910                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00911         } 
00912         <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a11">rt_sem_wait_timed</a>(sem, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00913 } 
00914 
00915 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_SEM */</span>
00916 
00917 <span class="preprocessor">#if CONFIG_RTAI_MSG</span>
00918 <span class="preprocessor"></span>
00919 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00920 {
00921         <span class="keywordflow">if</span> (node) {
00922                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00923                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDMSG, 0), 0LL, &amp;arg, SIZARG };
00924                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00925         } 
00926         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a0">rt_send</a>(task, msg);
00927 } 
00928 
00929 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00930 {
00931         <span class="keywordflow">if</span> (node) {
00932                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00933                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEND_IF, 0), 0LL, &amp;arg, SIZARG };
00934                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00935         } 
00936         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a1">rt_send_if</a>(task, msg);
00937 } 
00938 
00939 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME time)
00940 {
00941         <span class="keywordflow">if</span> (node) {
00942                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME time; } arg = { task, msg, time };
00943                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEND_UNTIL, 3), 0LL, &amp;arg, SIZARG };
00944                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00945         } 
00946         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a2">rt_send_until</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00947 } 
00948 
00949 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME delay)
00950 {
00951         <span class="keywordflow">if</span> (node) {
00952                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME delay; } arg = { task, msg, delay };
00953                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEND_TIMED, 3), 0LL, &amp;arg, SIZARG };
00954                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00955         } 
00956         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a3">rt_send_timed</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00957 } 
00958 
00959 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00960 {
00961         <span class="keywordflow">if</span> (!task || !node) {
00962                 <span class="keywordflow">return</span> rt_evdrp(task, msg);
00963         } 
00964         <span class="keywordflow">return</span> rt_evdrp(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00965 } 
00966 
00967 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00968 {
00969         <span class="keywordflow">if</span> (!task || !node) {
00970                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a4">rt_receive</a>(task, msg);
00971         } 
00972         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a4">rt_receive</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00973 } 
00974 
00975 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00976 {
00977         <span class="keywordflow">if</span> (!task || !node) {
00978                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a5">rt_receive_if</a>(task, msg);
00979         } 
00980         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a5">rt_receive_if</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00981 } 
00982 
00983 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME time)
00984 {
00985         <span class="keywordflow">if</span> (!task || !node) {
00986                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a6">rt_receive_until</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
00987         } 
00988         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a6">rt_receive_until</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time)) ? task : 0;
00989 } 
00990 
00991 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME delay)
00992 {
00993         <span class="keywordflow">if</span> (!task || !node) {
00994                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a7">rt_receive_timed</a>(task, msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
00995         } 
00996         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#a7">rt_receive_timed</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay)) ? task : 0;
00997 } 
00998 
00999 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
01000 {
01001         <span class="keywordflow">if</span> (node) {
01002                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg, ret };
01003                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCMSG, 0), UW1(3, 0), &amp;arg, SIZARG };
01004                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01005         }
01006         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a0">rt_rpc</a>(task, msg, ret);
01007 } 
01008 
01009 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
01010 {
01011         <span class="keywordflow">if</span> (node) {
01012                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg, ret };
01013                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPC_IF, 0), UW1(3, 0), &amp;arg, SIZARG };
01014                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01015         }
01016         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a1">rt_rpc_if</a>(task, msg, ret);
01017 } 
01018 
01019 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME time)
01020 {
01021         <span class="keywordflow">if</span> (node) {
01022                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME time; } arg = { task, msg, ret, time };
01023                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPC_UNTIL, 4), UW1(3, 0), &amp;arg, SIZARG };
01024                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01025         }
01026         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a2">rt_rpc_until</a>(task, msg, ret, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
01027 } 
01028 
01029 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME delay)
01030 {
01031         <span class="keywordflow">if</span> (node) {
01032                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME delay; } arg = { task, msg, ret, delay };
01033                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPC_TIMED, 4), UW1(3, 0), &amp;arg, SIZARG };
01034                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01035         }
01036         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a3">rt_rpc_timed</a>(task, msg, ret, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
01037 } 
01038 
01039 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_isrpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
01040 {
01041         <span class="keywordflow">if</span> (node) {
01042                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01043                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, ISRPC, 0), 0LL, &amp;arg, SIZARG };
01044                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01045         } 
01046         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a4">rt_isrpc</a>(task);
01047 } 
01048 
01049 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result)
01050 {
01051 
01052         <span class="keywordflow">if</span> (!task || !node) {
01053                 <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a5">rt_return</a>(task, result);
01054         } 
01055         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#a5">rt_return</a>(rt_find_asgn_stub(OWNER(node, task), 1), result) ? task : 0;
01056 } 
01057 
01058 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
01059 {
01060         <span class="keywordflow">if</span> (node) {
01061                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; } arg = { task, smsg, rmsg, ssize, rsize };
01062                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01063                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01064         }
01065         <span class="keywordflow">return</span> rt_rpcx(task, smsg, rmsg, ssize, rsize);
01066 } 
01067 
01068 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
01069 {
01070         <span class="keywordflow">if</span> (node) {
01071                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; } arg = { task, smsg, rmsg, ssize, rsize };
01072                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX_IF, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01073                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01074         }
01075         <span class="keywordflow">return</span> rt_rpcx_if(task, smsg, rmsg, ssize, rsize);
01076 } 
01077 
01078 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME time)
01079 {
01080         <span class="keywordflow">if</span> (node) {
01081                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; RTIME time; } arg = { task, smsg, rmsg, ssize, rsize, time };
01082                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX_UNTIL, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01083                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01084         }
01085         <span class="keywordflow">return</span> rt_rpcx_until(task, smsg, rmsg, ssize, rsize, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
01086 } 
01087 
01088 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME delay)
01089 {
01090         <span class="keywordflow">if</span> (node) {
01091                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; RTIME delay; } arg = { task, smsg, rmsg, ssize, rsize, delay };
01092                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX_TIMED, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01093                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01094         }
01095         <span class="keywordflow">return</span> rt_rpcx_timed(task, smsg, rmsg, ssize, rsize, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
01096 } 
01097 
01098 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
01099 {
01100         <span class="keywordflow">if</span> (node) {
01101                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
01102                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX, 0), UR1(2, 3), &amp;arg, SIZARG };
01103                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01104         }
01105         <span class="keywordflow">return</span> rt_sendx(task, msg, size);
01106 } 
01107 
01108 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
01109 {
01110         <span class="keywordflow">if</span> (node) {
01111                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
01112                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX_IF, 0), UR1(2, 3), &amp;arg, SIZARG };
01113                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01114         }
01115         <span class="keywordflow">return</span> rt_sendx_if(task, msg, size);
01116 } 
01117 
01118 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME time)
01119 {
01120         <span class="keywordflow">if</span> (node) {
01121                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME time; } arg = { task, msg, size, time };
01122                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG };
01123                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01124         }
01125         <span class="keywordflow">return</span> rt_sendx_until(task, msg, size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
01126 } 
01127 
01128 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME delay)
01129 {
01130         <span class="keywordflow">if</span> (node) {
01131                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME delay; } arg = { task, msg, size, delay };
01132                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG };
01133                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01134         }
01135         <span class="keywordflow">return</span> rt_sendx_timed(task, msg, size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
01136 } 
01137 
01138 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_returnx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
01139 {
01140 
01141         <span class="keywordflow">if</span> (!task || !node) {
01142                 <span class="keywordflow">return</span> rt_returnx(task, msg, size);
01143         } 
01144         <span class="keywordflow">return</span> rt_returnx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size) ? task : 0;
01145 } 
01146 
01147 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrpx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
01148 {
01149         <span class="keywordflow">if</span> (!task || !node) {
01150                 <span class="keywordflow">return</span> rt_evdrpx(task, msg, size, len);
01151         } 
01152         <span class="keywordflow">return</span> rt_evdrpx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
01153 } 
01154 
01155 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
01156 {
01157         <span class="keywordflow">if</span> (!task || !node) {
01158                 <span class="keywordflow">return</span> rt_receivex(task, msg, size, len);
01159         } 
01160         <span class="keywordflow">return</span> rt_receivex(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
01161 } 
01162 
01163 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
01164 {
01165         <span class="keywordflow">if</span> (!task || !node) {
01166                 <span class="keywordflow">return</span> rt_receivex_if(task, msg, size, len);
01167         } 
01168         <span class="keywordflow">return</span> rt_receivex_if(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
01169 } 
01170 
01171 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME time)
01172 {
01173         <span class="keywordflow">if</span> (!task || !node) {
01174                 <span class="keywordflow">return</span> rt_receivex_until(task, msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
01175         } 
01176         <span class="keywordflow">return</span> rt_receivex_until(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time)) ? task : 0;
01177 } 
01178 
01179 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME delay)
01180 {
01181         <span class="keywordflow">if</span> (!task || !node) {
01182                 <span class="keywordflow">return</span> rt_receivex_timed(task, msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
01183         } 
01184         <span class="keywordflow">return</span> rt_receivex_timed(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay)) ? task : 0;
01185 } 
01186 
01187 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MSG */</span>
01188 
01189 <span class="preprocessor">#if CONFIG_RTAI_MBX</span>
01190 <span class="preprocessor"></span>
01191 <span class="keyword">static</span> <span class="keyword">inline</span> MBX *RT_typed_named_mbx_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *mbx_name, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> qtype)
01192 {
01193         <span class="keywordflow">if</span> (node) {
01194                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *mbx_name; <span class="keywordtype">int</span> size; <span class="keywordtype">int</span> qype; <span class="keywordtype">int</span> namelen; } arg = { mbx_name, size, qtype, strlen(mbx_name) };
01195                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_MBX_INIT, 0), UR1(1, 4), &amp;arg, SIZARG };
01196                 <span class="keywordflow">return</span> (MBX *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01197         }
01198         <span class="keywordflow">return</span> (MBX *)rt_typed_named_mbx_init(mbx_name, size, qtype);
01199 }
01200 
01201 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_mbx_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx)
01202 {
01203         <span class="keywordflow">if</span> (node) {
01204                 <span class="keyword">struct </span>{ MBX *mbx; } arg = { mbx };
01205                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_MBX_DELETE, 0), 0LL, &amp;arg, SIZARG };
01206                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01207         }
01208         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a12">rt_mbx_delete</a>(mbx);
01209 }
01210 
01211 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01212 {
01213         <span class="keywordflow">if</span> (node) {
01214                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01215                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND, 0), UR1(2, 3), &amp;arg, SIZARG };
01216                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01217         } 
01218         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a13">rt_mbx_send</a>(mbx, msg, msg_size);
01219 } 
01220 
01221 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01222 {
01223         <span class="keywordflow">if</span> (node) {
01224                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01225                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_WP, 0), UR1(2, 3), &amp;arg, SIZARG };
01226                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01227         } 
01228         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a14">rt_mbx_send_wp</a>(mbx, msg, msg_size);
01229 } 
01230 
01231 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01232 {
01233         <span class="keywordflow">if</span> (node) {
01234                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01235                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_IF, 0), UR1(2, 3), &amp;arg, SIZARG };
01236                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01237         } 
01238         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a15">rt_mbx_send_if</a>(mbx, msg, msg_size);
01239 } 
01240 
01241 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
01242 {
01243         <span class="keywordflow">if</span> (node) {
01244                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
01245                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG };
01246                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01247         } 
01248         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a16">rt_mbx_send_until</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
01249 } 
01250 
01251 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
01252 {
01253         <span class="keywordflow">if</span> (node) {
01254                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
01255                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG };
01256                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01257         } 
01258         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a16">rt_mbx_send_until</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
01259 } 
01260 
01261 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01262 {
01263         <span class="keywordflow">if</span> (node) {
01264                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01265                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_EVDRP, 0), UW1(2, 3), &amp;arg, SIZARG };
01266                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01267         } 
01268         <span class="keywordflow">return</span> rt_mbx_evdrp(mbx, msg, msg_size);
01269 } 
01270 
01271 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01272 {
01273         <span class="keywordflow">if</span> (node) {
01274                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01275                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE, 0), UW1(2, 3), &amp;arg, SIZARG };
01276                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01277         } 
01278         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a18">rt_mbx_receive</a>(mbx, msg, msg_size);
01279 } 
01280 
01281 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01282 {
01283         <span class="keywordflow">if</span> (node) {
01284                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01285                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_WP, 0), UW1(2, 3), &amp;arg, SIZARG };
01286                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01287         } 
01288         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a19">rt_mbx_receive_wp</a>(mbx, msg, msg_size);
01289 } 
01290 
01291 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01292 {
01293         <span class="keywordflow">if</span> (node) {
01294                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01295                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_IF, 0), UW1(2, 3), &amp;arg, SIZARG };
01296                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01297         } 
01298         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a20">rt_mbx_receive_if</a>(mbx, msg, msg_size);
01299 } 
01300 
01301 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
01302 {
01303         <span class="keywordflow">if</span> (node) {
01304                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
01305                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_UNTIL, 4), UW1(2, 3), &amp;arg, SIZARG };
01306                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01307         }
01308         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a21">rt_mbx_receive_until</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(time));
01309 } 
01310 
01311 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
01312 {
01313         <span class="keywordflow">if</span> (node) {
01314                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
01315                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_TIMED, 4), UW1(2, 3), &amp;arg, SIZARG };
01316                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01317         }
01318         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#a22">rt_mbx_receive_timed</a>(mbx, msg, msg_size, <a class="code" href="sched__up_8c.html#a91">nano2count</a>(delay));
01319 } 
01320 
01321 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_get_net_rpc_ret(MBX *mbx, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *retval, <span class="keywordtype">void</span> *msg1, <span class="keywordtype">int</span> *msglen1, <span class="keywordtype">void</span> *msg2, <span class="keywordtype">int</span> *msglen2, RTIME timeout, <span class="keywordtype">int</span> type)
01322 {
01323         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> wsize, w2size; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> retval; } reply;
01324         <span class="keywordtype">int</span> ret;
01325 
01326         <span class="keywordflow">switch</span> (type) {
01327                 <span class="keywordflow">case</span> MBX_RECEIVE:
01328                         ret = <a class="code" href="group__mbx.html#a18">rt_mbx_receive</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply));
01329                         <span class="keywordflow">break</span>;
01330                 <span class="keywordflow">case</span> MBX_RECEIVE_WP:
01331                         ret = <a class="code" href="group__mbx.html#a19">rt_mbx_receive_wp</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply));
01332                         <span class="keywordflow">break</span>;
01333                 <span class="keywordflow">case</span> MBX_RECEIVE_IF:
01334                         ret = <a class="code" href="group__mbx.html#a20">rt_mbx_receive_if</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply));
01335                         <span class="keywordflow">break</span>;
01336                 <span class="keywordflow">case</span> MBX_RECEIVE_UNTIL:
01337                         ret = <a class="code" href="group__mbx.html#a21">rt_mbx_receive_until</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply), timeout);
01338                         <span class="keywordflow">break</span>;
01339                 <span class="keywordflow">case</span> MBX_RECEIVE_TIMED:
01340                         ret = <a class="code" href="group__mbx.html#a22">rt_mbx_receive_timed</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply), timeout);
01341                 <span class="keywordflow">default</span>:
01342                         ret = -1;
01343         }
01344         <span class="keywordflow">if</span> (!ret) {
01345                 *retval = reply.retval;
01346                 <span class="keywordflow">if</span> (reply.wsize) {
01347                         <span class="keywordflow">if</span> (*msglen1 &gt; reply.wsize) {
01348                                 *msglen1 = reply.wsize;
01349                         }
01350                         <a class="code" href="group__mbx.html#a18">rt_mbx_receive</a>(mbx, msg1, *msglen1);
01351                 } <span class="keywordflow">else</span> {
01352                         *msglen1 = 0;
01353                 }
01354                 <span class="keywordflow">if</span> (reply.w2size) {
01355                         <span class="keywordflow">if</span> (*msglen2 &gt; reply.w2size) {
01356                                 *msglen2 = reply.w2size;
01357                         }
01358                         <a class="code" href="group__mbx.html#a18">rt_mbx_receive</a>(mbx, msg2, *msglen2);
01359                 } <span class="keywordflow">else</span> {
01360                         *msglen2 = 0;
01361                 }
01362                 <span class="keywordflow">return</span> 0;
01363         }
01364         <span class="keywordflow">return</span> ret;
01365 }
01366 
01367 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MBX */</span>
01368 
01369 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
01370 
01371 <span class="comment">/*</span>
01372 <span class="comment"> * A set of compatibility defines for APIs that can be interpreted in various</span>
01373 <span class="comment"> * ways but do the same the same things always.</span>
01374 <span class="comment"> */</span>
01375 
01376 <span class="preprocessor">#define RT_isrpcx(task)  RT_isrpc(task)</span>
01377 <span class="preprocessor"></span>
01378 <span class="preprocessor">#define RT_waiting_return            rt_waiting_return</span>
01379 <span class="preprocessor"></span>
01380 <span class="preprocessor">#define RT_sync_net_rpc              rt_sync_net_rpc</span>
01381 <span class="preprocessor"></span>
01382 <span class="preprocessor">#define RT_request_port              rt_request_port</span>
01383 <span class="preprocessor"></span>
01384 <span class="preprocessor">#define RT_request_port_id           rt_request_port_id</span>
01385 <span class="preprocessor"></span>
01386 <span class="preprocessor">#define RT_request_port_mbx          rt_request_port_mbx</span>
01387 <span class="preprocessor"></span>
01388 <span class="preprocessor">#define RT_request_port_id_mbx       rt_request_port_id_mbx</span>
01389 <span class="preprocessor"></span>
01390 <span class="preprocessor">#define RT_request_soft_port         rt_request_soft_port</span>
01391 <span class="preprocessor"></span>
01392 <span class="preprocessor">#define RT_request_soft_port_id      rt_request_soft_port_id</span>
01393 <span class="preprocessor"></span>
01394 <span class="preprocessor">#define RT_request_soft_port_mbx     rt_request_soft_port_mbx</span>
01395 <span class="preprocessor"></span>
01396 <span class="preprocessor">#define RT_request_soft_port_id_mbx  rt_request_soft_port_id_mbx</span>
01397 <span class="preprocessor"></span>
01398 <span class="preprocessor">#define RT_request_hard_port         rt_request_hard_port</span>
01399 <span class="preprocessor"></span>
01400 <span class="preprocessor">#define RT_request_hard_port_id      rt_request_hard_port_id</span>
01401 <span class="preprocessor"></span>
01402 <span class="preprocessor">#define RT_request_hard_port_mbx     rt_request_hard_port_mbx</span>
01403 <span class="preprocessor"></span>
01404 <span class="preprocessor">#define RT_request_hard_port_id_mbx  rt_request_hard_port_id_mbx</span>
01405 <span class="preprocessor"></span>
01406 <span class="preprocessor">#define RT_release_port              rt_release_port</span>
01407 <span class="preprocessor"></span>
01408 <span class="preprocessor">#define rt_request_port              rt_request_soft_port </span>
01409 <span class="preprocessor"></span>
01410 <span class="preprocessor">#define rt_request_port_id           rt_request_soft_port_id</span>
01411 <span class="preprocessor"></span>
01412 <span class="preprocessor">#define rt_request_port_mbx          rt_request_soft_port_mbx</span>
01413 <span class="preprocessor"></span>
01414 <span class="preprocessor">#define rt_request_port_id_mbx       rt_request_soft_port_id_mbx</span>
01415 <span class="preprocessor"></span>
01416 <span class="comment">/*</span>
01417 <span class="comment"> * End of compatibility defines.</span>
01418 <span class="comment"> */</span>
01419 
01420 <span class="preprocessor">#define rt_request_soft_port(node) \</span>
01421 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, 0, 0)</span>
01422 <span class="preprocessor"></span>
01423 <span class="preprocessor">#define rt_request_soft_port_id(node, id) \</span>
01424 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, 0, 0)</span>
01425 <span class="preprocessor"></span>
01426 <span class="preprocessor">#define rt_request_soft_port_mbx(node, mbx) \</span>
01427 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, mbx, 0)</span>
01428 <span class="preprocessor"></span>
01429 <span class="preprocessor">#define rt_request_soft_port_id_mbx(node, id, mbx) \</span>
01430 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, mbx, 0)</span>
01431 <span class="preprocessor"></span>
01432 <span class="preprocessor">#define rt_request_hard_port(node) \</span>
01433 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, 0, 1)</span>
01434 <span class="preprocessor"></span>
01435 <span class="preprocessor">#define rt_request_hard_port_id(node, id) \</span>
01436 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, 0, 1)</span>
01437 <span class="preprocessor"></span>
01438 <span class="preprocessor">#define rt_request_hard_port_mbx(node, mbx) \</span>
01439 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, mbx, 1)</span>
01440 <span class="preprocessor"></span>
01441 <span class="preprocessor">#define rt_request_hard_port_id_mbx(node, id, mbx) \</span>
01442 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, mbx, 1)</span>
01443 <span class="preprocessor"></span>
01444 <span class="preprocessor">#define rt_release_port(node, port) \</span>
01445 <span class="preprocessor">        rt_send_req_rel_port(node, port, 0, 0, 0) </span>
01446 <span class="preprocessor"></span>
01447 <span class="preprocessor">#endif </span><span class="comment">/* __CONFIG_RTAI_LXRT_SUPPORT */</span>
01448 
01449 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_NETRPC_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Jan 11 16:25:17 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
