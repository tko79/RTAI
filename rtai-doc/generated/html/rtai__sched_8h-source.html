<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_sched.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_sched.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00006 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00007 <span class="comment"> * License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> * GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="preprocessor">#ifndef _RTAI_SCHED_H</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_SCHED_H</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include &lt;rtai.h&gt;</span>
00023 <span class="preprocessor">#ifndef __KERNEL__</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00025 <span class="preprocessor">#include &lt;time.h&gt;</span>
00026 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00027 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00028 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00029 
00030 <span class="preprocessor">#define RT_SCHED_UP   1</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SMP  2</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MUP  3</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#define RT_SCHED_HIGHEST_PRIORITY  0</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LOWEST_PRIORITY   0x3fffFfff</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LINUX_PRIORITY    0x7fffFfff</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define RT_SCHED_READY        1</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SUSPENDED    2</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_DELAYED      4</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEMAPHORE    8</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEND        16</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RECEIVE     32</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RPC         64</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RETURN     128</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MBXSUSP    256</span>
00047 <span class="preprocessor"></span>
00048 <span class="keyword">struct </span>rt_task_struct;
00049 
00050 <span class="preprocessor">#ifdef __KERNEL__</span>
00051 <span class="preprocessor"></span>
00052 <span class="preprocessor">#include &lt;linux/time.h&gt;</span>
00053 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00054 
00055 <span class="preprocessor">#define RT_TASK_MAGIC 0x754d2774</span>
00056 <span class="preprocessor"></span>
00057 <span class="preprocessor">#ifndef __cplusplus</span>
00058 <span class="preprocessor"></span>
00059 <span class="preprocessor">#include &lt;linux/sched.h&gt;</span>
00060 
00061 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_queue {
00062         <span class="keyword">struct </span>rt_queue *prev;
00063         <span class="keyword">struct </span>rt_queue *next;
00064         <span class="keyword">struct </span>rt_task_struct *task;
00065 } QUEUE;
00066 
00067 <span class="keyword">struct </span>mcb_t {
00068     <span class="keywordtype">void</span> *sbuf;
00069     <span class="keywordtype">int</span> sbytes;
00070     <span class="keywordtype">void</span> *rbuf;
00071     <span class="keywordtype">int</span> rbytes;
00072 };
00073 
00074 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_ExitHandler {
00075     <span class="comment">/* Exit handler functions are called like C++ destructors in</span>
00076 <span class="comment">       rt_task_delete(). */</span>
00077     <span class="keyword">struct </span>rt_ExitHandler *nxt;
00078     void (*fun) (<span class="keywordtype">void</span> *arg1, <span class="keywordtype">int</span> arg2);
00079     <span class="keywordtype">void</span> *arg1;
00080     <span class="keywordtype">int</span>   arg2;
00081 } XHDL;
00082 
00083 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00084 
00085     <span class="keywordtype">int</span> *stack;
00086     <span class="keywordtype">int</span> uses_fpu;
00087     <span class="keywordtype">int</span> magic;
00088     <span class="keyword">volatile</span> <span class="keywordtype">int</span> state, running;
00089     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> runnable_on_cpus;
00090     <span class="keywordtype">int</span> *stack_bottom;
00091     <span class="keyword">volatile</span> <span class="keywordtype">int</span> priority;
00092     <span class="keywordtype">int</span> base_priority;
00093     <span class="keywordtype">int</span> policy;
00094     <span class="keywordtype">int</span> sched_lock_priority;
00095     <span class="keyword">struct </span>rt_task_struct *prio_passed_to;
00096     RTIME period;
00097     RTIME resume_time;
00098     RTIME yield_time;
00099     <span class="keywordtype">int</span> rr_quantum;
00100     <span class="keywordtype">int</span> rr_remaining;
00101     <span class="keywordtype">int</span> suspdepth;
00102     <span class="keyword">struct </span>rt_queue queue;
00103     <span class="keywordtype">int</span> owndres;
00104     <span class="keyword">struct </span>rt_queue *blocked_on;
00105     <span class="keyword">struct </span>rt_queue msg_queue;
00106     <span class="keywordtype">int</span> tid;    <span class="comment">/* trace ID */</span>
00107     <span class="keywordtype">unsigned</span> msg;
00108     <span class="keyword">struct </span>rt_queue ret_queue;
00109     void (*signal)(<span class="keywordtype">void</span>);
00110     FPU_ENV fpu_reg;
00111     <span class="keyword">struct </span>rt_task_struct *prev;
00112     <span class="keyword">struct </span>rt_task_struct *next;
00113     <span class="keyword">struct </span>rt_task_struct *tprev;
00114     <span class="keyword">struct </span>rt_task_struct *tnext;
00115     <span class="keyword">struct </span>rt_task_struct *rprev;
00116     <span class="keyword">struct </span>rt_task_struct *rnext;
00117 
00118     <span class="comment">/* Appended for calls from LINUX. */</span>
00119     <span class="keywordtype">int</span> *fun_args, *bstack;
00120     <span class="keyword">struct </span>task_struct *lnxtsk;
00121     <span class="keywordtype">long</span> <span class="keywordtype">long</span> retval;
00122     <span class="keywordtype">char</span> *msg_buf[2];
00123     <span class="keywordtype">int</span> max_msg_size[2];
00124     <span class="keywordtype">char</span> task_name[16];
00125     <span class="keywordtype">void</span> *system_data_ptr;
00126     <span class="keyword">struct </span>rt_task_struct *nextp;
00127     <span class="keyword">struct </span>rt_task_struct *prevp;
00128 
00129     <span class="comment">/* Added to support user specific trap handlers. */</span>
00130     RT_TRAP_HANDLER task_trap_handler[RTAI_NR_TRAPS];
00131 
00132     <span class="comment">/* Added from rtai-22. */</span>
00133     void (*usp_signal)(<span class="keywordtype">void</span>);
00134     <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pstate;
00135     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags;
00136     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags_mask;
00137     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> force_soft;
00138     <span class="keyword">volatile</span> <span class="keywordtype">int</span> is_hard;
00139 
00140     <span class="comment">/* Added to terminate qBlks. */</span>
00141     <span class="keywordtype">void</span> *tick_queue;
00142 
00143     <span class="comment">/* Added to terminate re-entry of user space functions. */</span>
00144 
00145     <span class="keywordtype">void</span> *trap_handler_data; 
00146     <span class="keywordtype">int</span> trap_signo;
00147 
00148     <span class="comment">/* For use by watchdog. */</span>
00149     <span class="keywordtype">int</span> resync_frame;
00150 
00151     <span class="comment">/* For use by exit handler functions. */</span>
00152     XHDL *ExitHook;
00153     <span class="keywordtype">int</span> linux_signal;
00154     <span class="keywordtype">int</span> errno;
00155     void (*linux_signal_handler)(<span class="keywordtype">int</span> sig);
00156     RTIME exectime[2];
00157     <span class="keyword">struct </span>mcb_t mcb;
00158 
00159 } RT_TASK __attribute__ ((__aligned__ (16)));
00160 
00161 <span class="preprocessor">#else </span><span class="comment">/* __cplusplus */</span>
00162 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00163 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00164 
00165 <span class="keywordtype">int</span> <a class="code" href="sched__up_8c.html#a50">rt_task_init</a>(<span class="keyword">struct</span> rt_task_struct *task,
00166                  <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>), <span class="keywordtype">int</span> data,
00167                  <span class="keywordtype">int</span> stack_size,
00168                  <span class="keywordtype">int</span> priority,
00169                  <span class="keywordtype">int</span> uses_fpu,
00170                  <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00171 
00172 <span class="keywordtype">int</span> <a class="code" href="sched__up_8c.html#a51">rt_task_init_cpuid</a>(<span class="keyword">struct</span> rt_task_struct *task,
00173                        <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>),
00174                        <span class="keywordtype">int</span> data,
00175                        <span class="keywordtype">int</span> stack_size,
00176                        <span class="keywordtype">int</span> priority,
00177                        <span class="keywordtype">int</span> uses_fpu,
00178                        <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00179                        <span class="keywordtype">unsigned</span> run_on_cpu);
00180 
00181 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a54">rt_set_runnable_on_cpus</a>(<span class="keyword">struct</span> rt_task_struct *task,
00182                              <span class="keywordtype">unsigned</span> cpu_mask);
00183 
00184 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a55">rt_set_runnable_on_cpuid</a>(<span class="keyword">struct</span> rt_task_struct *task,
00185                               <span class="keywordtype">unsigned</span> cpuid);
00186 
00187 <span class="keywordtype">void</span> rt_set_sched_policy(<span class="keyword">struct</span> rt_task_struct *task,
00188                          <span class="keywordtype">int</span> policy,
00189                          <span class="keywordtype">int</span> rr_quantum_ns);
00190 
00191 <span class="keywordtype">int</span> <a class="code" href="sched__up_8c.html#a61">rt_task_delete</a>(<span class="keyword">struct</span> rt_task_struct *task);
00192 
00193 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a11">rt_get_task_state</a>(<span class="keyword">struct</span> rt_task_struct *task);
00194 
00195 <span class="keywordtype">void</span> rt_gettimeorig(RTIME time_orig[]);
00196 
00197 <span class="keywordtype">int</span> rt_get_timer_cpu(<span class="keywordtype">void</span>);
00198 
00199 <span class="keywordtype">int</span> rt_is_hard_timer_running(<span class="keywordtype">void</span>);
00200 
00201 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a23">rt_set_periodic_mode</a>(<span class="keywordtype">void</span>);
00202 
00203 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a24">rt_set_oneshot_mode</a>(<span class="keywordtype">void</span>);
00204 
00205 RTIME <a class="code" href="sched__up_8c.html#a68">start_rt_timer</a>(<span class="keywordtype">int</span> period);
00206 
00207 RTIME start_rt_timer_cpuid(<span class="keywordtype">int</span> period,
00208                            <span class="keywordtype">int</span> cpuid);
00209 
00210 <span class="preprocessor">#define start_rt_timer_ns(period) start_rt_timer(nano2count((period)))</span>
00211 <span class="preprocessor"></span>
00212 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a70">start_rt_apic_timers</a>(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode,
00213                           <span class="keywordtype">unsigned</span> rcvr_jiffies_cpuid);
00214 
00215 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a18">stop_rt_timer</a>(<span class="keywordtype">void</span>);
00216 
00217 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="common_8c.html#a7">rt_whoami</a>(<span class="keywordtype">void</span>);
00218 
00219 <span class="keywordtype">int</span> rt_sched_type(<span class="keywordtype">void</span>);
00220 
00221 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a14">rt_task_signal_handler</a>(<span class="keyword">struct</span> rt_task_struct *task,
00222                            <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>));
00223 
00224 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a13">rt_task_use_fpu</a>(<span class="keyword">struct</span> rt_task_struct *task,
00225                     <span class="keywordtype">int</span> use_fpu_flag);
00226   
00227 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a12">rt_linux_use_fpu</a>(<span class="keywordtype">int</span> use_fpu_flag);
00228 
00229 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a73">rt_preempt_always</a>(<span class="keywordtype">int</span> yes_no);
00230 
00231 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a74">rt_preempt_always_cpuid</a>(<span class="keywordtype">int</span> yes_no,
00232                              <span class="keywordtype">unsigned</span> cpuid);
00233 
00234 RTIME <a class="code" href="sched__up_8c.html#a90">count2nano</a>(RTIME timercounts);
00235 
00236 RTIME <a class="code" href="sched__up_8c.html#a91">nano2count</a>(RTIME nanosecs);
00237   
00238 RTIME <a class="code" href="sched__up_8c.html#a92">count2nano_cpuid</a>(RTIME timercounts,
00239                        <span class="keywordtype">unsigned</span> cpuid);
00240 
00241 RTIME <a class="code" href="sched__up_8c.html#a93">nano2count_cpuid</a>(RTIME nanosecs,
00242                        <span class="keywordtype">unsigned</span> cpuid);
00243   
00244 RTIME <a class="code" href="group__lxrt.html#a19">rt_get_time</a>(<span class="keywordtype">void</span>);
00245 
00246 RTIME <a class="code" href="sched__up_8c.html#a95">rt_get_time_cpuid</a>(<span class="keywordtype">unsigned</span> cpuid);
00247 
00248 RTIME <a class="code" href="group__lxrt.html#a30">rt_get_time_ns</a>(<span class="keywordtype">void</span>);
00249 
00250 RTIME <a class="code" href="sched__up_8c.html#a97">rt_get_time_ns_cpuid</a>(<span class="keywordtype">unsigned</span> cpuid);
00251 
00252 RTIME <a class="code" href="group__lxrt.html#a31">rt_get_cpu_time_ns</a>(<span class="keywordtype">void</span>);
00253 
00254 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a4">rt_get_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00255 
00256 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a5">rt_get_inher_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00257 
00258 <span class="keywordtype">void</span> rt_spv_RMS(<span class="keywordtype">int</span> cpuid);
00259 
00260 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a6">rt_change_prio</a>(<span class="keyword">struct</span> rt_task_struct *task,
00261                    <span class="keywordtype">int</span> priority);
00262 
00263 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#a4">rt_sched_lock</a>(<span class="keywordtype">void</span>);
00264 
00265 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#a5">rt_sched_unlock</a>(<span class="keywordtype">void</span>);
00266 
00267 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a8">rt_task_yield</a>(<span class="keywordtype">void</span>);
00268 
00269 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a9">rt_task_suspend</a>(<span class="keyword">struct</span> rt_task_struct *task);
00270 
00271 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a10">rt_task_resume</a>(<span class="keyword">struct</span> rt_task_struct *task);
00272 
00273 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a16">rt_task_make_periodic_relative_ns</a>(<span class="keyword">struct</span> rt_task_struct *task,
00274                                       RTIME start_delay,
00275                                       RTIME period);
00276 
00277 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a17">rt_task_make_periodic</a>(<span class="keyword">struct</span> rt_task_struct *task,
00278                           RTIME start_time,
00279                           RTIME period);
00280 
00281 <span class="keywordtype">void</span> rt_task_set_resume_end_times(RTIME resume,
00282                                   RTIME end);
00283 
00284 <span class="keywordtype">int</span> rt_set_resume_time(<span class="keyword">struct</span> rt_task_struct *task,
00285                        RTIME new_resume_time);
00286 
00287 <span class="keywordtype">int</span> rt_set_period(<span class="keyword">struct</span> rt_task_struct *task,
00288                   RTIME new_period);
00289 
00290 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a13">rt_task_wait_period</a>(<span class="keywordtype">void</span>);
00291 
00292 <span class="keywordtype">void</span> rt_schedule(<span class="keywordtype">void</span>);
00293 
00294 RTIME <a class="code" href="common_8c.html#a22">next_period</a>(<span class="keywordtype">void</span>);
00295 
00296 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a23">rt_busy_sleep</a>(<span class="keywordtype">int</span> nanosecs);
00297 
00298 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a24">rt_sleep</a>(RTIME delay);
00299 
00300 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a25">rt_sleep_until</a>(RTIME time);
00301 
00302 <span class="keywordtype">int</span> rt_task_wakeup_sleeping(<span class="keyword">struct</span> rt_task_struct *task);
00303 
00304 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00305                                           <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00306                                           <span class="keywordtype">int</span> data,
00307                                           <span class="keywordtype">int</span> stack_size,
00308                                           <span class="keywordtype">int</span> prio,
00309                                           <span class="keywordtype">int</span> uses_fpu,
00310                                           <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00311 
00312 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init_cpuid(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00313                                                 <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00314                                                 <span class="keywordtype">int</span> data,
00315                                                 <span class="keywordtype">int</span> stack_size,
00316                                                 <span class="keywordtype">int</span> prio,
00317                                                 <span class="keywordtype">int</span> uses_fpu,
00318                                                 <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00319                                                 <span class="keywordtype">unsigned</span> run_on_cpu);
00320 
00321 <span class="keywordtype">int</span> rt_named_task_delete(<span class="keyword">struct</span> rt_task_struct *task);
00322 
00323 RT_TRAP_HANDLER rt_set_task_trap_handler(<span class="keyword">struct</span> rt_task_struct *task,
00324                                          <span class="keywordtype">unsigned</span> vec,
00325                                          RT_TRAP_HANDLER handler);
00326 
00327 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timeval2count(<span class="keyword">struct</span> timeval *t)
00328 {
00329         <span class="keywordflow">return</span> <a class="code" href="sched__up_8c.html#a91">nano2count</a>(t-&gt;tv_sec*1000000000LL + t-&gt;tv_usec*1000);
00330 }
00331 
00332 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timeval(RTIME rt, <span class="keyword">struct</span> timeval *t)
00333 {
00334         t-&gt;tv_sec = ulldiv(<a class="code" href="sched__up_8c.html#a90">count2nano</a>(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_usec);
00335         t-&gt;tv_usec /= 1000;
00336 }
00337 
00338 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2count(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00339 {
00340         <span class="keywordflow">return</span> <a class="code" href="sched__up_8c.html#a91">nano2count</a>(t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec);
00341 }
00342 
00343 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00344 {
00345         t-&gt;tv_sec = ulldiv(<a class="code" href="sched__up_8c.html#a90">count2nano</a>(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00346 }
00347 
00348 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2nanos(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00349 {
00350         <span class="keywordflow">return</span> t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec;
00351 }
00352 
00353 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> nanos2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00354 {
00355         t-&gt;tv_sec = ulldiv(rt, 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00356 }
00357 
00358 <span class="preprocessor">#ifdef __cplusplus</span>
00359 <span class="preprocessor"></span>}
00360 <span class="preprocessor">#else </span><span class="comment">/* !__cplusplus */</span>
00361 
00362 <span class="comment">/* FIXME: These calls should move to rtai_schedcore.h */</span>
00363 
00364 RT_TASK *rt_get_base_linux_task(RT_TASK **base_linux_task);
00365 
00366 RT_TASK *rt_alloc_dynamic_task(<span class="keywordtype">void</span>);
00367 
00368 <span class="keywordtype">void</span> rt_enq_ready_edf_task(RT_TASK *ready_task);
00369 
00370 <span class="keywordtype">void</span> rt_enq_ready_task(RT_TASK *ready_task);
00371 
00372 <span class="keywordtype">int</span> rt_renq_ready_task(RT_TASK *ready_task,
00373                        <span class="keywordtype">int</span> priority);
00374 
00375 <span class="keywordtype">void</span> rt_rem_ready_task(RT_TASK *task);
00376 
00377 <span class="keywordtype">void</span> rt_rem_ready_current(RT_TASK *rt_current);
00378 
00379 <span class="keywordtype">void</span> rt_enq_timed_task(RT_TASK *timed_task);
00380 
00381 <span class="keywordtype">void</span> rt_rem_timed_task(RT_TASK *task);
00382 
00383 <span class="keywordtype">void</span> rt_dequeue_blocked(RT_TASK *task);
00384 
00385 RT_TASK **rt_register_watchdog(RT_TASK *wdog,
00386                                <span class="keywordtype">int</span> cpuid);
00387 
00388 <span class="keywordtype">void</span> rt_deregister_watchdog(RT_TASK *wdog,
00389                             <span class="keywordtype">int</span> cpuid);
00390 
00391 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00392 
00393 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00394 
00395 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00396 <span class="preprocessor"></span>
00397 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00398     <span class="keywordtype">int</span> opaque;
00399 } RT_TASK;
00400 
00401 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueBlock {
00402     <span class="keywordtype">int</span> opaque;
00403 } QBLK;
00404 
00405 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueHook {
00406     <span class="keywordtype">int</span> opaque;
00407 } QHOOK;
00408 
00409 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00410 
00411 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_SCHED_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Jan 11 16:25:16 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
